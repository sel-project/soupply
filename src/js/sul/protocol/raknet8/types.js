/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 * 
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/raknet8.xml
 */
/** @module sul/protocol/raknet8/types */

const Types = {

	Address: class extends Buffer {

		constructor(type=0, ipv4=0, ipv6=[], port=0) {
			super();
			this.type = type;
			this.ipv4 = ipv4;
			this.ipv6 = ipv6;
			this.port = port;
		}

		/** @return {Uint8Array} */
		encode() {
			this._buffer = [];
			this.writeBigEndianByte(this.type);
			if(type==4){ this.writeBigEndianInt(this.ipv4); }
			if(type==6){ this.writeBytes(this.ipv6); }
			this.writeBigEndianShort(this.port);
			return new Uint8Array(this._buffer);
		}

		/** @param {(Uint8Array|Array)} buffer */
		decode(_buffer) {
			this._buffer = Array.from(_buffer);
			this.type=this.readBigEndianByte();
			if(type==4){ this.ipv4=this.readBigEndianInt(); }
			if(type==6){ var aramabn=16; this.ipv6=this.readBytes(aramabn); }
			this.port=this.readBigEndianShort();
			return this;
		}

		/** @param {(Uint8Array|Array)} buffer */
		static fromBuffer(buffer) {
			return new Types.Address().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Address(type: " + this.type + ", ipv4: " + this.ipv4 + ", ipv6: " + this.ipv6 + ", port: " + this.port + ")";
		}

	},

	Acknowledge: class extends Buffer {

		constructor(unique=false, first=0, last=0) {
			super();
			this.unique = unique;
			this.first = first;
			this.last = last;
		}

		/** @return {Uint8Array} */
		encode() {
			this._buffer = [];
			this.writeBigEndianByte(this.unique?1:0);
			this.writeLittleEndianTriad(this.first);
			if(unique==false){ this.writeLittleEndianTriad(this.last); }
			return new Uint8Array(this._buffer);
		}

		/** @param {(Uint8Array|Array)} buffer */
		decode(_buffer) {
			this._buffer = Array.from(_buffer);
			this.unique=this.readBigEndianByte()!==0;
			this.first=this.readLittleEndianTriad();
			if(unique==false){ this.last=this.readLittleEndianTriad(); }
			return this;
		}

		/** @param {(Uint8Array|Array)} buffer */
		static fromBuffer(buffer) {
			return new Types.Acknowledge().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Acknowledge(unique: " + this.unique + ", first: " + this.first + ", last: " + this.last + ")";
		}

	},

	Encapsulation: class extends Buffer {

		constructor(info=0, length=0, messageIndex=0, orderIndex=0, orderChannel=0, split=null, payload=null) {
			super();
			this.info = info;
			this.length = length;
			this.messageIndex = messageIndex;
			this.orderIndex = orderIndex;
			this.orderChannel = orderChannel;
			this.split = split;
			this.payload = payload;
		}

		/** @return {Uint8Array} */
		encode() {
			this._buffer = [];
			this.writeBigEndianByte(this.info);
			this.writeBigEndianShort(this.length);
			if((info&0x7F)>=64){ this.writeLittleEndianTriad(this.messageIndex); }
			if((info&0x7F)>=96){ this.writeLittleEndianTriad(this.orderIndex); }
			if((info&0x7F)>=96){ this.writeBigEndianByte(this.orderChannel); }
			if((info&0x10)!=0){ this.writeBytes(this.split.encode()); }
			this.writeBytes(this.payload);
			return new Uint8Array(this._buffer);
		}

		/** @param {(Uint8Array|Array)} buffer */
		decode(_buffer) {
			this._buffer = Array.from(_buffer);
			this.info=this.readBigEndianByte();
			this.length=this.readBigEndianShort();
			if((info&0x7F)>=64){ this.messageIndex=this.readLittleEndianTriad(); }
			if((info&0x7F)>=96){ this.orderIndex=this.readLittleEndianTriad(); }
			if((info&0x7F)>=96){ this.orderChannel=this.readBigEndianByte(); }
			if((info&0x10)!=0){ this.split=Types.Split.fromBuffer(this._buffer); this._buffer=this.split._buffer; }
			this.payload=Array.from(this._buffer); this._buffer=[];
			return this;
		}

		/** @param {(Uint8Array|Array)} buffer */
		static fromBuffer(buffer) {
			return new Types.Encapsulation().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Encapsulation(info: " + this.info + ", length: " + this.length + ", messageIndex: " + this.messageIndex + ", orderIndex: " + this.orderIndex + ", orderChannel: " + this.orderChannel + ", split: " + this.split + ", payload: " + this.payload + ")";
		}

	},

	Split: class extends Buffer {

		constructor(count=0, id=0, order=0) {
			super();
			this.count = count;
			this.id = id;
			this.order = order;
		}

		/** @return {Uint8Array} */
		encode() {
			this._buffer = [];
			this.writeBigEndianInt(this.count);
			this.writeBigEndianShort(this.id);
			this.writeBigEndianInt(this.order);
			return new Uint8Array(this._buffer);
		}

		/** @param {(Uint8Array|Array)} buffer */
		decode(_buffer) {
			this._buffer = Array.from(_buffer);
			this.count=this.readBigEndianInt();
			this.id=this.readBigEndianShort();
			this.order=this.readBigEndianInt();
			return this;
		}

		/** @param {(Uint8Array|Array)} buffer */
		static fromBuffer(buffer) {
			return new Types.Split().decode(buffer);
		}

		/** @return {string} */
		toString() {
			return "Split(count: " + this.count + ", id: " + this.id + ", order: " + this.order + ")";
		}

	}

}

//export { Types }
