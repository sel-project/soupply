/*
 * This file was automatically generated by sel-utils and
 * released under the GNU General Public License version 3.
 *
 * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE
 * Repository: https://github.com/sel-project/sel-utils
 * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/pocket100.xml
 */
module sul.protocol.pocket100.play;

import std.bitmanip : write, peek;
static import std.conv;
import std.system : Endian;
import std.typetuple : TypeTuple;
import std.typecons : Tuple;
import std.uuid : UUID;

import sul.utils.buffer;
import sul.utils.var;

static import sul.protocol.pocket100.types;

import sul.metadata.pocket100;

alias Packets = TypeTuple!(Login, PlayStatus, ServerHandshake, ClientMagic, Disconnect, Batch, ResourcePacksInfo, ResourcePackClientResponse, Text, SetTime, StartGame, AddPlayer, AddEntity, RemoveEntity, AddItemEntity, AddHangingEntity, TakeItemEntity, MoveEntity, MovePlayer, RiderJump, RemoveBlock, UpdateBlock, AddPainting, Explode, LevelSoundEvent, LevelEvent, BlockEvent, EntityEvent, MobEffect, UpdateAttributes, MobEquipment, MobArmorEquipment, Interact, UseItem, PlayerAction, PlayerFall, HurtArmor, SetEntityData, SetEntityMotion, SetEntityLink, SetHealth, SetSpawnPosition, Animate, Respawn, DropItem, InventoryAction, ContainerOpen, ContainerClose, ContainerSetSlot, ContainerSetData, ContainerSetContent, CraftingData, CraftingEvent, AdventureSettings, BlockEntityData, PlayerInput, FullChunkData, SetCheatsEnabled, SetDifficulty, ChangeDimension, SetPlayerGametype, PlayerList, TelemetryEvent, SpawnExperienceOrb, ClientboundMapItemData, MapInfoRequest, RequestChunkRadius, ChunkRadiusUpdated, ItemFrameDropItem, ReplaceSelectedItem, Camera, AddItem, BossEvent, ShowCredits, AvailableCommands, CommandStep, ResourcePackDataInfo, ResourcePackChunkData, ResourcePackChunkRequest);

class Login : Buffer {

	public enum ubyte ID = 1;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// edition
	public enum ubyte CLASSIC = 0;
	public enum ubyte EDUCATION = 1;

	public enum string[] FIELDS = ["protocol", "edition", "body_"];

	public uint protocol;
	public ubyte edition;
	public ubyte[] body_;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint protocol, ubyte edition=ubyte.init, ubyte[] body_=(ubyte[]).init) {
		this.protocol = protocol;
		this.edition = edition;
		this.body_ = body_;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUint(protocol);
		writeBigEndianUbyte(edition);
		writeBytes(varuint.encode(cast(uint)body_.length)); writeBytes(body_);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		protocol=readBigEndianUint();
		edition=readBigEndianUbyte();
		body_.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+body_.length){ body_=_buffer[_index.._index+body_.length].dup; _index+=body_.length; }
	}

	public static pure nothrow @safe Login fromBuffer(bool readId=true)(ubyte[] buffer) {
		Login ret = new Login();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Login(protocol: " ~ std.conv.to!string(this.protocol) ~ ", edition: " ~ std.conv.to!string(this.edition) ~ ", body_: " ~ std.conv.to!string(this.body_) ~ ")";
	}

}

class PlayStatus : Buffer {

	public enum ubyte ID = 2;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// status
	public enum uint OK = 0;
	public enum uint OUTDATED_CLIENT = 1;
	public enum uint OUTDATED_SERVER = 2;
	public enum uint SPAWNED = 3;
	public enum uint INVALID_TENANT = 4;
	public enum uint EDITION_MISMATCH = 5;

	public enum string[] FIELDS = ["status"];

	public uint status;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint status) {
		this.status = status;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUint(status);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		status=readBigEndianUint();
	}

	public static pure nothrow @safe PlayStatus fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayStatus ret = new PlayStatus();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayStatus(status: " ~ std.conv.to!string(this.status) ~ ")";
	}

}

class ServerHandshake : Buffer {

	public enum ubyte ID = 3;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["serverPublicKey", "token"];

	public string serverPublicKey;
	public ubyte[] token;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string serverPublicKey, ubyte[] token=(ubyte[]).init) {
		this.serverPublicKey = serverPublicKey;
		this.token = token;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)serverPublicKey.length)); writeString(serverPublicKey);
		writeBytes(varuint.encode(cast(uint)token.length)); writeBytes(token);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		uint c2vydmvyuhvibglj=varuint.decode(_buffer, &_index); serverPublicKey=readString(c2vydmvyuhvibglj);
		token.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+token.length){ token=_buffer[_index.._index+token.length].dup; _index+=token.length; }
	}

	public static pure nothrow @safe ServerHandshake fromBuffer(bool readId=true)(ubyte[] buffer) {
		ServerHandshake ret = new ServerHandshake();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ServerHandshake(serverPublicKey: " ~ std.conv.to!string(this.serverPublicKey) ~ ", token: " ~ std.conv.to!string(this.token) ~ ")";
	}

}

class ClientMagic : Buffer {

	public enum ubyte ID = 4;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = [];

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
	}

	public static pure nothrow @safe ClientMagic fromBuffer(bool readId=true)(ubyte[] buffer) {
		ClientMagic ret = new ClientMagic();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ClientMagic()";
	}

}

class Disconnect : Buffer {

	public enum ubyte ID = 5;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["hideDisconnectionScreen", "message"];

	public bool hideDisconnectionScreen;
	public string message;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(bool hideDisconnectionScreen, string message=string.init) {
		this.hideDisconnectionScreen = hideDisconnectionScreen;
		this.message = message;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianBool(hideDisconnectionScreen);
		writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		hideDisconnectionScreen=readBigEndianBool();
		uint bwvzc2fnzq=varuint.decode(_buffer, &_index); message=readString(bwvzc2fnzq);
	}

	public static pure nothrow @safe Disconnect fromBuffer(bool readId=true)(ubyte[] buffer) {
		Disconnect ret = new Disconnect();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Disconnect(hideDisconnectionScreen: " ~ std.conv.to!string(this.hideDisconnectionScreen) ~ ", message: " ~ std.conv.to!string(this.message) ~ ")";
	}

}

class Batch : Buffer {

	public enum ubyte ID = 6;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["data"];

	public ubyte[] data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte[] data) {
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)data.length)); writeBytes(data);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		data.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+data.length){ data=_buffer[_index.._index+data.length].dup; _index+=data.length; }
	}

	public static pure nothrow @safe Batch fromBuffer(bool readId=true)(ubyte[] buffer) {
		Batch ret = new Batch();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Batch(data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class ResourcePacksInfo : Buffer {

	public enum ubyte ID = 7;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["mustAccept", "behaviourPacks", "resourcePacks"];

	public bool mustAccept;
	public sul.protocol.pocket100.types.Pack[] behaviourPacks;
	public sul.protocol.pocket100.types.Pack[] resourcePacks;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(bool mustAccept, sul.protocol.pocket100.types.Pack[] behaviourPacks=(sul.protocol.pocket100.types.Pack[]).init, sul.protocol.pocket100.types.Pack[] resourcePacks=(sul.protocol.pocket100.types.Pack[]).init) {
		this.mustAccept = mustAccept;
		this.behaviourPacks = behaviourPacks;
		this.resourcePacks = resourcePacks;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianBool(mustAccept);
		writeBytes(varuint.encode(cast(uint)behaviourPacks.length)); foreach(ymvoyxzpb3vyugfj;behaviourPacks){ ymvoyxzpb3vyugfj.encode(bufferInstance); }
		writeBytes(varuint.encode(cast(uint)resourcePacks.length)); foreach(cmvzb3vyy2vqywnr;resourcePacks){ cmvzb3vyy2vqywnr.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		mustAccept=readBigEndianBool();
		behaviourPacks.length=varuint.decode(_buffer, &_index); foreach(ref ymvoyxzpb3vyugfj;behaviourPacks){ ymvoyxzpb3vyugfj.decode(bufferInstance); }
		resourcePacks.length=varuint.decode(_buffer, &_index); foreach(ref cmvzb3vyy2vqywnr;resourcePacks){ cmvzb3vyy2vqywnr.decode(bufferInstance); }
	}

	public static pure nothrow @safe ResourcePacksInfo fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePacksInfo ret = new ResourcePacksInfo();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePacksInfo(mustAccept: " ~ std.conv.to!string(this.mustAccept) ~ ", behaviourPacks: " ~ std.conv.to!string(this.behaviourPacks) ~ ", resourcePacks: " ~ std.conv.to!string(this.resourcePacks) ~ ")";
	}

}

class ResourcePackClientResponse : Buffer {

	public enum ubyte ID = 9;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["status", "resourcePackVersion"];

	public ubyte status;
	public ushort resourcePackVersion;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte status, ushort resourcePackVersion=ushort.init) {
		this.status = status;
		this.resourcePackVersion = resourcePackVersion;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(status);
		writeBigEndianUshort(resourcePackVersion);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		status=readBigEndianUbyte();
		resourcePackVersion=readBigEndianUshort();
	}

	public static pure nothrow @safe ResourcePackClientResponse fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePackClientResponse ret = new ResourcePackClientResponse();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePackClientResponse(status: " ~ std.conv.to!string(this.status) ~ ", resourcePackVersion: " ~ std.conv.to!string(this.resourcePackVersion) ~ ")";
	}

}

class Text : Buffer {

	public enum ubyte ID = 10;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["type"];

	public ubyte type;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte type) {
		this.type = type;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(type);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		type=readBigEndianUbyte();
	}

	public static pure nothrow @safe Text fromBuffer(bool readId=true)(ubyte[] buffer) {
		Text ret = new Text();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Text(type: " ~ std.conv.to!string(this.type) ~ ")";
	}

	alias _encode = encode;

	enum string variantField = "type";

	alias Variants = TypeTuple!(Raw, Chat, Translation, Popup, Tip, System, Whisper);

	public class Raw {

		public enum typeof(type) TYPE = 0;

		public enum string[] FIELDS = ["message"];

		public string message;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string message) {
			this.message = message;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 0;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint bwvzc2fnzq=varuint.decode(_buffer, &_index); message=readString(bwvzc2fnzq);
		}

		public override string toString() {
			return "Text.Raw(message: " ~ std.conv.to!string(this.message) ~ ")";
		}

	}

	public class Chat {

		public enum typeof(type) TYPE = 1;

		public enum string[] FIELDS = ["sender", "message"];

		public string sender;
		public string message;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string sender, string message=string.init) {
			this.sender = sender;
			this.message = message;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 1;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)sender.length)); writeString(sender);
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint c2vuzgvy=varuint.decode(_buffer, &_index); sender=readString(c2vuzgvy);
			uint bwvzc2fnzq=varuint.decode(_buffer, &_index); message=readString(bwvzc2fnzq);
		}

		public override string toString() {
			return "Text.Chat(sender: " ~ std.conv.to!string(this.sender) ~ ", message: " ~ std.conv.to!string(this.message) ~ ")";
		}

	}

	public class Translation {

		public enum typeof(type) TYPE = 2;

		public enum string[] FIELDS = ["message", "parameters"];

		public string message;
		public string[] parameters;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string message, string[] parameters=(string[]).init) {
			this.message = message;
			this.parameters = parameters;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 2;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			writeBytes(varuint.encode(cast(uint)parameters.length)); foreach(cgfyyw1ldgvycw;parameters){ writeBytes(varuint.encode(cast(uint)cgfyyw1ldgvycw.length)); writeString(cgfyyw1ldgvycw); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint bwvzc2fnzq=varuint.decode(_buffer, &_index); message=readString(bwvzc2fnzq);
			parameters.length=varuint.decode(_buffer, &_index); foreach(ref cgfyyw1ldgvycw;parameters){ uint y2dmexl3mwxkz3z5=varuint.decode(_buffer, &_index); cgfyyw1ldgvycw=readString(y2dmexl3mwxkz3z5); }
		}

		public override string toString() {
			return "Text.Translation(message: " ~ std.conv.to!string(this.message) ~ ", parameters: " ~ std.conv.to!string(this.parameters) ~ ")";
		}

	}

	public class Popup {

		public enum typeof(type) TYPE = 3;

		public enum string[] FIELDS = ["title", "subtitle"];

		public string title;
		public string subtitle;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string title, string subtitle=string.init) {
			this.title = title;
			this.subtitle = subtitle;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 3;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)title.length)); writeString(title);
			writeBytes(varuint.encode(cast(uint)subtitle.length)); writeString(subtitle);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint dgl0bgu=varuint.decode(_buffer, &_index); title=readString(dgl0bgu);
			uint c3vidgl0bgu=varuint.decode(_buffer, &_index); subtitle=readString(c3vidgl0bgu);
		}

		public override string toString() {
			return "Text.Popup(title: " ~ std.conv.to!string(this.title) ~ ", subtitle: " ~ std.conv.to!string(this.subtitle) ~ ")";
		}

	}

	public class Tip {

		public enum typeof(type) TYPE = 4;

		public enum string[] FIELDS = ["message"];

		public string message;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string message) {
			this.message = message;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 4;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint bwvzc2fnzq=varuint.decode(_buffer, &_index); message=readString(bwvzc2fnzq);
		}

		public override string toString() {
			return "Text.Tip(message: " ~ std.conv.to!string(this.message) ~ ")";
		}

	}

	public class System {

		public enum typeof(type) TYPE = 5;

		public enum string[] FIELDS = ["message"];

		public string message;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string message) {
			this.message = message;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 5;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint bwvzc2fnzq=varuint.decode(_buffer, &_index); message=readString(bwvzc2fnzq);
		}

		public override string toString() {
			return "Text.System(message: " ~ std.conv.to!string(this.message) ~ ")";
		}

	}

	public class Whisper {

		public enum typeof(type) TYPE = 6;

		public enum string[] FIELDS = ["sender", "message"];

		public string sender;
		public string message;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(string sender, string message=string.init) {
			this.sender = sender;
			this.message = message;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			type = 6;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)sender.length)); writeString(sender);
			writeBytes(varuint.encode(cast(uint)message.length)); writeString(message);
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			uint c2vuzgvy=varuint.decode(_buffer, &_index); sender=readString(c2vuzgvy);
			uint bwvzc2fnzq=varuint.decode(_buffer, &_index); message=readString(bwvzc2fnzq);
		}

		public override string toString() {
			return "Text.Whisper(sender: " ~ std.conv.to!string(this.sender) ~ ", message: " ~ std.conv.to!string(this.message) ~ ")";
		}

	}

}

class SetTime : Buffer {

	public enum ubyte ID = 11;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["time", "daylightCycle"];

	public int time;
	public bool daylightCycle;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int time, bool daylightCycle=bool.init) {
		this.time = time;
		this.daylightCycle = daylightCycle;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(time));
		writeBigEndianBool(daylightCycle);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		time=varint.decode(_buffer, &_index);
		daylightCycle=readBigEndianBool();
	}

	public static pure nothrow @safe SetTime fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetTime ret = new SetTime();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetTime(time: " ~ std.conv.to!string(this.time) ~ ", daylightCycle: " ~ std.conv.to!string(this.daylightCycle) ~ ")";
	}

}

class StartGame : Buffer {

	public enum ubyte ID = 12;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// dimension
	public enum int OVERWORLD = 0;
	public enum int NETHER = 1;
	public enum int END = 2;

	// generator
	public enum int OLD = 0;
	public enum int INFINITE = 1;
	public enum int FLAT = 2;

	// world gamemode
	public enum int SURVIVAL = 0;
	public enum int CREATIVE = 1;

	// difficulty
	public enum int PEACEFUL = 0;
	public enum int EASY = 1;
	public enum int NORMAL = 2;
	public enum int HARD = 3;

	// edition
	public enum ubyte CLASSIC = 0;
	public enum ubyte EDUCATION = 1;

	public enum string[] FIELDS = ["entityId", "runtimeId", "position", "yaw", "pitch", "seed", "dimension", "generator", "worldGamemode", "difficulty", "spawnPosition", "loadedInCreative", "time", "edition", "rainLevel", "lightingLevel", "cheatsEnabled", "textureRequired", "levelId", "worldName"];

	public long entityId;
	public long runtimeId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public float yaw;
	public float pitch;
	public int seed;
	public int dimension;
	public int generator;
	public int worldGamemode;
	public int difficulty;
	public Tuple!(int, "x", int, "y", int, "z") spawnPosition;
	public bool loadedInCreative;
	public int time;
	public ubyte edition;
	public float rainLevel;
	public float lightingLevel;
	public bool cheatsEnabled;
	public bool textureRequired;
	public string levelId;
	public string worldName;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, long runtimeId=long.init, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, float yaw=float.init, float pitch=float.init, int seed=int.init, int dimension=int.init, int generator=int.init, int worldGamemode=int.init, int difficulty=int.init, Tuple!(int, "x", int, "y", int, "z") spawnPosition=Tuple!(int, "x", int, "y", int, "z").init, bool loadedInCreative=bool.init, int time=int.init, ubyte edition=ubyte.init, float rainLevel=float.init, float lightingLevel=float.init, bool cheatsEnabled=bool.init, bool textureRequired=bool.init, string levelId=string.init, string worldName=string.init) {
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.position = position;
		this.yaw = yaw;
		this.pitch = pitch;
		this.seed = seed;
		this.dimension = dimension;
		this.generator = generator;
		this.worldGamemode = worldGamemode;
		this.difficulty = difficulty;
		this.spawnPosition = spawnPosition;
		this.loadedInCreative = loadedInCreative;
		this.time = time;
		this.edition = edition;
		this.rainLevel = rainLevel;
		this.lightingLevel = lightingLevel;
		this.cheatsEnabled = cheatsEnabled;
		this.textureRequired = textureRequired;
		this.levelId = levelId;
		this.worldName = worldName;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varlong.encode(runtimeId));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(yaw);
		writeLittleEndianFloat(pitch);
		writeBytes(varint.encode(seed));
		writeBytes(varint.encode(dimension));
		writeBytes(varint.encode(generator));
		writeBytes(varint.encode(worldGamemode));
		writeBytes(varint.encode(difficulty));
		writeBytes(varint.encode(spawnPosition.x)); writeBytes(varint.encode(spawnPosition.y)); writeBytes(varint.encode(spawnPosition.z));
		writeBigEndianBool(loadedInCreative);
		writeBytes(varint.encode(time));
		writeBigEndianUbyte(edition);
		writeLittleEndianFloat(rainLevel);
		writeLittleEndianFloat(lightingLevel);
		writeBigEndianBool(cheatsEnabled);
		writeBigEndianBool(textureRequired);
		writeBytes(varuint.encode(cast(uint)levelId.length)); writeString(levelId);
		writeBytes(varuint.encode(cast(uint)worldName.length)); writeString(worldName);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varlong.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		yaw=readLittleEndianFloat();
		pitch=readLittleEndianFloat();
		seed=varint.decode(_buffer, &_index);
		dimension=varint.decode(_buffer, &_index);
		generator=varint.decode(_buffer, &_index);
		worldGamemode=varint.decode(_buffer, &_index);
		difficulty=varint.decode(_buffer, &_index);
		spawnPosition.x=varint.decode(_buffer, &_index); spawnPosition.y=varint.decode(_buffer, &_index); spawnPosition.z=varint.decode(_buffer, &_index);
		loadedInCreative=readBigEndianBool();
		time=varint.decode(_buffer, &_index);
		edition=readBigEndianUbyte();
		rainLevel=readLittleEndianFloat();
		lightingLevel=readLittleEndianFloat();
		cheatsEnabled=readBigEndianBool();
		textureRequired=readBigEndianBool();
		uint bgv2zwxjza=varuint.decode(_buffer, &_index); levelId=readString(bgv2zwxjza);
		uint d29ybgroyw1l=varuint.decode(_buffer, &_index); worldName=readString(d29ybgroyw1l);
	}

	public static pure nothrow @safe StartGame fromBuffer(bool readId=true)(ubyte[] buffer) {
		StartGame ret = new StartGame();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "StartGame(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", seed: " ~ std.conv.to!string(this.seed) ~ ", dimension: " ~ std.conv.to!string(this.dimension) ~ ", generator: " ~ std.conv.to!string(this.generator) ~ ", worldGamemode: " ~ std.conv.to!string(this.worldGamemode) ~ ", difficulty: " ~ std.conv.to!string(this.difficulty) ~ ", spawnPosition: " ~ std.conv.to!string(this.spawnPosition) ~ ", loadedInCreative: " ~ std.conv.to!string(this.loadedInCreative) ~ ", time: " ~ std.conv.to!string(this.time) ~ ", edition: " ~ std.conv.to!string(this.edition) ~ ", rainLevel: " ~ std.conv.to!string(this.rainLevel) ~ ", lightingLevel: " ~ std.conv.to!string(this.lightingLevel) ~ ", cheatsEnabled: " ~ std.conv.to!string(this.cheatsEnabled) ~ ", textureRequired: " ~ std.conv.to!string(this.textureRequired) ~ ", levelId: " ~ std.conv.to!string(this.levelId) ~ ", worldName: " ~ std.conv.to!string(this.worldName) ~ ")";
	}

}

class AddPlayer : Buffer {

	public enum ubyte ID = 13;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["uuid", "username", "entityId", "runtimeId", "position", "motion", "pitch", "headYaw", "yaw", "heldItem", "metadata"];

	public UUID uuid;
	public string username;
	public long entityId;
	public long runtimeId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") motion;
	public float pitch;
	public float headYaw;
	public float yaw;
	public sul.protocol.pocket100.types.Slot heldItem;
	public Metadata metadata;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(UUID uuid, string username=string.init, long entityId=long.init, long runtimeId=long.init, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, Tuple!(float, "x", float, "y", float, "z") motion=Tuple!(float, "x", float, "y", float, "z").init, float pitch=float.init, float headYaw=float.init, float yaw=float.init, sul.protocol.pocket100.types.Slot heldItem=sul.protocol.pocket100.types.Slot.init, Metadata metadata=Metadata.init) {
		this.uuid = uuid;
		this.username = username;
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.position = position;
		this.motion = motion;
		this.pitch = pitch;
		this.headYaw = headYaw;
		this.yaw = yaw;
		this.heldItem = heldItem;
		this.metadata = metadata;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(uuid.data);
		writeBytes(varuint.encode(cast(uint)username.length)); writeString(username);
		writeBytes(varlong.encode(entityId));
		writeBytes(varlong.encode(runtimeId));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(motion.x); writeLittleEndianFloat(motion.y); writeLittleEndianFloat(motion.z);
		writeLittleEndianFloat(pitch);
		writeLittleEndianFloat(headYaw);
		writeLittleEndianFloat(yaw);
		heldItem.encode(bufferInstance);
		metadata.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		if(_buffer.length>=_index+16){ ubyte[16] dxvpza=_buffer[_index.._index+16].dup; _index+=16; uuid=UUID(dxvpza); }
		uint dxnlcm5hbwu=varuint.decode(_buffer, &_index); username=readString(dxnlcm5hbwu);
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varlong.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		motion.x=readLittleEndianFloat(); motion.y=readLittleEndianFloat(); motion.z=readLittleEndianFloat();
		pitch=readLittleEndianFloat();
		headYaw=readLittleEndianFloat();
		yaw=readLittleEndianFloat();
		heldItem.decode(bufferInstance);
		metadata=Metadata.decode(bufferInstance);
	}

	public static pure nothrow @safe AddPlayer fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddPlayer ret = new AddPlayer();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddPlayer(uuid: " ~ std.conv.to!string(this.uuid) ~ ", username: " ~ std.conv.to!string(this.username) ~ ", entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", headYaw: " ~ std.conv.to!string(this.headYaw) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", heldItem: " ~ std.conv.to!string(this.heldItem) ~ ", metadata: " ~ std.conv.to!string(this.metadata) ~ ")";
	}

}

class AddEntity : Buffer {

	public enum ubyte ID = 14;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "runtimeId", "type", "position", "motion", "pitch", "yaw", "attributes", "metadata", "links"];

	public long entityId;
	public long runtimeId;
	public uint type;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") motion;
	public float pitch;
	public float yaw;
	public sul.protocol.pocket100.types.Attribute[] attributes;
	public Metadata metadata;
	public long[] links;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, long runtimeId=long.init, uint type=uint.init, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, Tuple!(float, "x", float, "y", float, "z") motion=Tuple!(float, "x", float, "y", float, "z").init, float pitch=float.init, float yaw=float.init, sul.protocol.pocket100.types.Attribute[] attributes=(sul.protocol.pocket100.types.Attribute[]).init, Metadata metadata=Metadata.init, long[] links=(long[]).init) {
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.type = type;
		this.position = position;
		this.motion = motion;
		this.pitch = pitch;
		this.yaw = yaw;
		this.attributes = attributes;
		this.metadata = metadata;
		this.links = links;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varlong.encode(runtimeId));
		writeBytes(varuint.encode(type));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(motion.x); writeLittleEndianFloat(motion.y); writeLittleEndianFloat(motion.z);
		writeLittleEndianFloat(pitch);
		writeLittleEndianFloat(yaw);
		writeBytes(varuint.encode(cast(uint)attributes.length)); foreach(yxr0cmlidxrlcw;attributes){ yxr0cmlidxrlcw.encode(bufferInstance); }
		metadata.encode(bufferInstance);
		writeBytes(varuint.encode(cast(uint)links.length)); foreach(bglua3m;links){ writeBytes(varlong.encode(bglua3m)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varlong.decode(_buffer, &_index);
		type=varuint.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		motion.x=readLittleEndianFloat(); motion.y=readLittleEndianFloat(); motion.z=readLittleEndianFloat();
		pitch=readLittleEndianFloat();
		yaw=readLittleEndianFloat();
		attributes.length=varuint.decode(_buffer, &_index); foreach(ref yxr0cmlidxrlcw;attributes){ yxr0cmlidxrlcw.decode(bufferInstance); }
		metadata=Metadata.decode(bufferInstance);
		links.length=varuint.decode(_buffer, &_index); foreach(ref bglua3m;links){ bglua3m=varlong.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe AddEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddEntity ret = new AddEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", attributes: " ~ std.conv.to!string(this.attributes) ~ ", metadata: " ~ std.conv.to!string(this.metadata) ~ ", links: " ~ std.conv.to!string(this.links) ~ ")";
	}

}

class RemoveEntity : Buffer {

	public enum ubyte ID = 15;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId"];

	public long entityId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId) {
		this.entityId = entityId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe RemoveEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		RemoveEntity ret = new RemoveEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "RemoveEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ")";
	}

}

class AddItemEntity : Buffer {

	public enum ubyte ID = 16;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "runtimeId", "item", "position", "motion"];

	public long entityId;
	public long runtimeId;
	public sul.protocol.pocket100.types.Slot item;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public Tuple!(float, "x", float, "y", float, "z") motion;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, long runtimeId=long.init, sul.protocol.pocket100.types.Slot item=sul.protocol.pocket100.types.Slot.init, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, Tuple!(float, "x", float, "y", float, "z") motion=Tuple!(float, "x", float, "y", float, "z").init) {
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.item = item;
		this.position = position;
		this.motion = motion;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varlong.encode(runtimeId));
		item.encode(bufferInstance);
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(motion.x); writeLittleEndianFloat(motion.y); writeLittleEndianFloat(motion.z);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varlong.decode(_buffer, &_index);
		item.decode(bufferInstance);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		motion.x=readLittleEndianFloat(); motion.y=readLittleEndianFloat(); motion.z=readLittleEndianFloat();
	}

	public static pure nothrow @safe AddItemEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddItemEntity ret = new AddItemEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddItemEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", item: " ~ std.conv.to!string(this.item) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ")";
	}

}

class AddHangingEntity : Buffer {

	public enum ubyte ID = 17;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "runtimeId", "position", "unknown3"];

	public long entityId;
	public long runtimeId;
	public sul.protocol.pocket100.types.BlockPosition position;
	public int unknown3;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, long runtimeId=long.init, sul.protocol.pocket100.types.BlockPosition position=sul.protocol.pocket100.types.BlockPosition.init, int unknown3=int.init) {
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.position = position;
		this.unknown3 = unknown3;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varlong.encode(runtimeId));
		position.encode(bufferInstance);
		writeBytes(varint.encode(unknown3));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varlong.decode(_buffer, &_index);
		position.decode(bufferInstance);
		unknown3=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe AddHangingEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddHangingEntity ret = new AddHangingEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddHangingEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", unknown3: " ~ std.conv.to!string(this.unknown3) ~ ")";
	}

}

class TakeItemEntity : Buffer {

	public enum ubyte ID = 18;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["taken", "collector"];

	public long taken;
	public long collector;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long taken, long collector=long.init) {
		this.taken = taken;
		this.collector = collector;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(taken));
		writeBytes(varlong.encode(collector));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		taken=varlong.decode(_buffer, &_index);
		collector=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe TakeItemEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		TakeItemEntity ret = new TakeItemEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "TakeItemEntity(taken: " ~ std.conv.to!string(this.taken) ~ ", collector: " ~ std.conv.to!string(this.collector) ~ ")";
	}

}

class MoveEntity : Buffer {

	public enum ubyte ID = 19;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "position", "pitch", "headYaw", "yaw"];

	public long entityId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public ubyte pitch;
	public ubyte headYaw;
	public ubyte yaw;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, ubyte pitch=ubyte.init, ubyte headYaw=ubyte.init, ubyte yaw=ubyte.init) {
		this.entityId = entityId;
		this.position = position;
		this.pitch = pitch;
		this.headYaw = headYaw;
		this.yaw = yaw;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeBigEndianUbyte(pitch);
		writeBigEndianUbyte(headYaw);
		writeBigEndianUbyte(yaw);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		pitch=readBigEndianUbyte();
		headYaw=readBigEndianUbyte();
		yaw=readBigEndianUbyte();
	}

	public static pure nothrow @safe MoveEntity fromBuffer(bool readId=true)(ubyte[] buffer) {
		MoveEntity ret = new MoveEntity();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MoveEntity(entityId: " ~ std.conv.to!string(this.entityId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", headYaw: " ~ std.conv.to!string(this.headYaw) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ")";
	}

}

class MovePlayer : Buffer {

	public enum ubyte ID = 20;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// animation
	public enum ubyte FULL = 0;
	public enum ubyte NONE = 1;
	public enum ubyte ROTATION = 2;

	public enum string[] FIELDS = ["entityId", "position", "pitch", "headYaw", "yaw", "animation", "onGround"];

	public long entityId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public float pitch;
	public float headYaw;
	public float yaw;
	public ubyte animation;
	public bool onGround;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, float pitch=float.init, float headYaw=float.init, float yaw=float.init, ubyte animation=ubyte.init, bool onGround=bool.init) {
		this.entityId = entityId;
		this.position = position;
		this.pitch = pitch;
		this.headYaw = headYaw;
		this.yaw = yaw;
		this.animation = animation;
		this.onGround = onGround;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(pitch);
		writeLittleEndianFloat(headYaw);
		writeLittleEndianFloat(yaw);
		writeBigEndianUbyte(animation);
		writeBigEndianBool(onGround);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		pitch=readLittleEndianFloat();
		headYaw=readLittleEndianFloat();
		yaw=readLittleEndianFloat();
		animation=readBigEndianUbyte();
		onGround=readBigEndianBool();
	}

	public static pure nothrow @safe MovePlayer fromBuffer(bool readId=true)(ubyte[] buffer) {
		MovePlayer ret = new MovePlayer();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MovePlayer(entityId: " ~ std.conv.to!string(this.entityId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", headYaw: " ~ std.conv.to!string(this.headYaw) ~ ", yaw: " ~ std.conv.to!string(this.yaw) ~ ", animation: " ~ std.conv.to!string(this.animation) ~ ", onGround: " ~ std.conv.to!string(this.onGround) ~ ")";
	}

}

class RiderJump : Buffer {

	public enum ubyte ID = 21;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["rider"];

	public long rider;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long rider) {
		this.rider = rider;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(rider));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		rider=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe RiderJump fromBuffer(bool readId=true)(ubyte[] buffer) {
		RiderJump ret = new RiderJump();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "RiderJump(rider: " ~ std.conv.to!string(this.rider) ~ ")";
	}

}

class RemoveBlock : Buffer {

	public enum ubyte ID = 22;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["position"];

	public sul.protocol.pocket100.types.BlockPosition position;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket100.types.BlockPosition position) {
		this.position = position;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		position.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.decode(bufferInstance);
	}

	public static pure nothrow @safe RemoveBlock fromBuffer(bool readId=true)(ubyte[] buffer) {
		RemoveBlock ret = new RemoveBlock();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "RemoveBlock(position: " ~ std.conv.to!string(this.position) ~ ")";
	}

}

class UpdateBlock : Buffer {

	public enum ubyte ID = 23;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// flags and meta
	public enum uint NEIGHBORS = 1;
	public enum uint NETWORK = 2;
	public enum uint NO_GRAPHIC = 4;
	public enum uint PRIORITY = 8;

	public enum string[] FIELDS = ["position", "block", "flagsAndMeta"];

	public sul.protocol.pocket100.types.BlockPosition position;
	public uint block;
	public uint flagsAndMeta;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket100.types.BlockPosition position, uint block=uint.init, uint flagsAndMeta=uint.init) {
		this.position = position;
		this.block = block;
		this.flagsAndMeta = flagsAndMeta;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		position.encode(bufferInstance);
		writeBytes(varuint.encode(block));
		writeBytes(varuint.encode(flagsAndMeta));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.decode(bufferInstance);
		block=varuint.decode(_buffer, &_index);
		flagsAndMeta=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe UpdateBlock fromBuffer(bool readId=true)(ubyte[] buffer) {
		UpdateBlock ret = new UpdateBlock();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "UpdateBlock(position: " ~ std.conv.to!string(this.position) ~ ", block: " ~ std.conv.to!string(this.block) ~ ", flagsAndMeta: " ~ std.conv.to!string(this.flagsAndMeta) ~ ")";
	}

}

class AddPainting : Buffer {

	public enum ubyte ID = 24;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "runtimeId", "position", "direction", "title"];

	public long entityId;
	public long runtimeId;
	public sul.protocol.pocket100.types.BlockPosition position;
	public int direction;
	public string title;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, long runtimeId=long.init, sul.protocol.pocket100.types.BlockPosition position=sul.protocol.pocket100.types.BlockPosition.init, int direction=int.init, string title=string.init) {
		this.entityId = entityId;
		this.runtimeId = runtimeId;
		this.position = position;
		this.direction = direction;
		this.title = title;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varlong.encode(runtimeId));
		position.encode(bufferInstance);
		writeBytes(varint.encode(direction));
		writeBytes(varuint.encode(cast(uint)title.length)); writeString(title);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		runtimeId=varlong.decode(_buffer, &_index);
		position.decode(bufferInstance);
		direction=varint.decode(_buffer, &_index);
		uint dgl0bgu=varuint.decode(_buffer, &_index); title=readString(dgl0bgu);
	}

	public static pure nothrow @safe AddPainting fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddPainting ret = new AddPainting();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddPainting(entityId: " ~ std.conv.to!string(this.entityId) ~ ", runtimeId: " ~ std.conv.to!string(this.runtimeId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", direction: " ~ std.conv.to!string(this.direction) ~ ", title: " ~ std.conv.to!string(this.title) ~ ")";
	}

}

class Explode : Buffer {

	public enum ubyte ID = 25;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "radius", "destroyedBlocks"];

	public Tuple!(float, "x", float, "y", float, "z") position;
	public float radius;
	public sul.protocol.pocket100.types.BlockPosition[] destroyedBlocks;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(float, "x", float, "y", float, "z") position, float radius=float.init, sul.protocol.pocket100.types.BlockPosition[] destroyedBlocks=(sul.protocol.pocket100.types.BlockPosition[]).init) {
		this.position = position;
		this.radius = radius;
		this.destroyedBlocks = destroyedBlocks;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeLittleEndianFloat(radius);
		writeBytes(varuint.encode(cast(uint)destroyedBlocks.length)); foreach(zgvzdhjvewvkqmxv;destroyedBlocks){ zgvzdhjvewvkqmxv.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		radius=readLittleEndianFloat();
		destroyedBlocks.length=varuint.decode(_buffer, &_index); foreach(ref zgvzdhjvewvkqmxv;destroyedBlocks){ zgvzdhjvewvkqmxv.decode(bufferInstance); }
	}

	public static pure nothrow @safe Explode fromBuffer(bool readId=true)(ubyte[] buffer) {
		Explode ret = new Explode();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Explode(position: " ~ std.conv.to!string(this.position) ~ ", radius: " ~ std.conv.to!string(this.radius) ~ ", destroyedBlocks: " ~ std.conv.to!string(this.destroyedBlocks) ~ ")";
	}

}

class LevelSoundEvent : Buffer {

	public enum ubyte ID = 26;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// sound
	public enum ubyte ITEM_USE_ON = 0;
	public enum ubyte HIT = 1;
	public enum ubyte STEP = 2;
	public enum ubyte JUMP = 3;
	public enum ubyte BREAK = 4;
	public enum ubyte PLACE = 5;
	public enum ubyte HEAVY_STEP = 6;
	public enum ubyte GALLOP = 7;
	public enum ubyte FALL = 8;
	public enum ubyte AMBIENT = 9;
	public enum ubyte AMBIENT_BABY = 10;
	public enum ubyte AMBIENT_IN_WATER = 11;
	public enum ubyte BREATHE = 12;
	public enum ubyte DEATH = 13;
	public enum ubyte DEATH_IN_WATER = 14;
	public enum ubyte DEATH_TO_ZOMBIE = 15;
	public enum ubyte HURT = 16;
	public enum ubyte HURT_IN_WATER = 17;
	public enum ubyte MAD = 18;
	public enum ubyte BOOST = 19;
	public enum ubyte BOW = 20;
	public enum ubyte SQUISH_BIG = 21;
	public enum ubyte SQUISH_SMALL = 22;
	public enum ubyte FALL_BIG = 23;
	public enum ubyte FALL_SMALL = 24;
	public enum ubyte SPLASH = 25;
	public enum ubyte FIZZ = 26;
	public enum ubyte FLAP = 27;
	public enum ubyte SWIM = 28;
	public enum ubyte DRINK = 29;
	public enum ubyte EAT = 30;
	public enum ubyte TAKEOFF = 31;
	public enum ubyte SHAKE = 32;
	public enum ubyte PLOP = 33;
	public enum ubyte LAND = 34;
	public enum ubyte SADDLE = 35;
	public enum ubyte ARMOR = 36;
	public enum ubyte ADD_CHEST = 37;
	public enum ubyte THROW = 38;
	public enum ubyte ATTACK = 39;
	public enum ubyte ATTACK_NODAMAGE = 40;
	public enum ubyte WARN = 41;
	public enum ubyte SHEAR = 42;
	public enum ubyte MILK = 43;
	public enum ubyte THUNDER = 44;
	public enum ubyte EXPLODE = 45;
	public enum ubyte FIRE = 46;
	public enum ubyte IGNITE = 47;
	public enum ubyte FUSE = 48;
	public enum ubyte STARE = 49;
	public enum ubyte SPAWN = 50;
	public enum ubyte SHOOT = 51;
	public enum ubyte BREAK_BLOCK = 52;
	public enum ubyte REMEDY = 53;
	public enum ubyte UNFECT = 54;
	public enum ubyte LEVELUP = 55;
	public enum ubyte BOW_HIT = 56;
	public enum ubyte BULLET_HIT = 57;
	public enum ubyte EXTINGUISH_FIRE = 58;
	public enum ubyte ITEM_FIZZ = 59;
	public enum ubyte CHEST_OPEN = 60;
	public enum ubyte CHEST_CLOSED = 61;
	public enum ubyte POWER_ON = 62;
	public enum ubyte POWER_OFF = 63;
	public enum ubyte ATTACH = 64;
	public enum ubyte DETACH = 65;
	public enum ubyte DENY = 66;
	public enum ubyte TRIPOD = 67;
	public enum ubyte POP = 68;
	public enum ubyte DROP_SLOT = 69;
	public enum ubyte NOTE = 70;
	public enum ubyte THORNS = 71;
	public enum ubyte PISTON_IN = 72;
	public enum ubyte PISTON_OUT = 73;
	public enum ubyte PORTAL = 74;
	public enum ubyte WATER = 75;
	public enum ubyte LAVA_POP = 76;
	public enum ubyte LAVA = 77;
	public enum ubyte BURP = 78;
	public enum ubyte BUCKET_FILL_WATER = 79;
	public enum ubyte BUCKET_FILL_LAVA = 80;
	public enum ubyte BUCKET_EMPTY_WATER = 81;
	public enum ubyte BUCKET_EMPTY_LAVA = 82;
	public enum ubyte GUARDIAN_FLOP = 83;
	public enum ubyte ELDERGUARDIAN_CURSE = 84;
	public enum ubyte MOB_WARNING = 85;
	public enum ubyte MOB_WARNING_BABY = 86;
	public enum ubyte TELEPORT = 87;
	public enum ubyte SHULKER_OPEN = 88;
	public enum ubyte SHULKER_CLOSE = 89;
	public enum ubyte DEFAULT = 90;
	public enum ubyte UNDEFINED = 91;

	public enum string[] FIELDS = ["sound", "position", "volume", "pitch", "unknown4"];

	public ubyte sound;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public uint volume;
	public int pitch;
	public bool unknown4;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte sound, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, uint volume=uint.init, int pitch=int.init, bool unknown4=bool.init) {
		this.sound = sound;
		this.position = position;
		this.volume = volume;
		this.pitch = pitch;
		this.unknown4 = unknown4;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(sound);
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeBytes(varuint.encode(volume));
		writeBytes(varint.encode(pitch));
		writeBigEndianBool(unknown4);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		sound=readBigEndianUbyte();
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		volume=varuint.decode(_buffer, &_index);
		pitch=varint.decode(_buffer, &_index);
		unknown4=readBigEndianBool();
	}

	public static pure nothrow @safe LevelSoundEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		LevelSoundEvent ret = new LevelSoundEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "LevelSoundEvent(sound: " ~ std.conv.to!string(this.sound) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", volume: " ~ std.conv.to!string(this.volume) ~ ", pitch: " ~ std.conv.to!string(this.pitch) ~ ", unknown4: " ~ std.conv.to!string(this.unknown4) ~ ")";
	}

}

class LevelEvent : Buffer {

	public enum ubyte ID = 27;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// event id
	public enum int START_RAIN = 3001;
	public enum int START_THUNDER = 3002;
	public enum int STOP_RAIN = 3003;
	public enum int STOP_THUNDER = 3004;
	public enum int SET_DATA = 4000;
	public enum int PLAYERS_SLEEPING = 9800;
	public enum int BUBBLE = 16385;
	public enum int CRITICAL = 16386;
	public enum int BLOCK_FORCE_FIELD = 16387;
	public enum int SMOKE = 16388;
	public enum int EXPLODE = 16389;
	public enum int EVAPORATION = 16390;
	public enum int FLAME = 16391;
	public enum int LAVA = 16392;
	public enum int LARGE_SMOKE = 16393;
	public enum int REDSTONE = 16394;
	public enum int RISING_RED_DUST = 16395;
	public enum int ITEM_BREAK = 16396;
	public enum int SNOWBALL_POOF = 16397;
	public enum int HUGE_EXPLODE = 16398;
	public enum int HUGE_EXPLODE_SEED = 16399;
	public enum int MOB_FLAME = 16400;
	public enum int HEART = 16401;
	public enum int TERRAIN = 16402;
	public enum int TOWN_AURA = 16403;
	public enum int PORTAL = 16404;
	public enum int WATER_SPLASH = 16405;
	public enum int WATER_WAKE = 16406;
	public enum int DRIP_WATER = 16407;
	public enum int DRIP_LAVA = 16408;
	public enum int FALLING_DUST = 16409;
	public enum int MOB_SPELL = 16410;
	public enum int MOB_SPELL_AMBIENT = 16411;
	public enum int MOB_SPELL_INSTANTANEOUS = 16412;
	public enum int INK = 16413;
	public enum int SLIME = 16414;
	public enum int RAIN_SPLASH = 16415;
	public enum int VILLAGER_ANGRY = 16416;
	public enum int VILLAGER_HAPPY = 16417;
	public enum int ENCHANTMENT_TABLE = 16418;
	public enum int TRACKING_EMITTER = 16419;
	public enum int NOTE = 16420;
	public enum int WITCH_SPELL = 16421;
	public enum int CARROT = 16422;
	public enum int END_ROD = 16424;
	public enum int DRAGON_BREATH = 16425;
	public enum int SHOOT = 2000;
	public enum int DESTROY = 2001;

	public enum string[] FIELDS = ["eventId", "position", "data"];

	public int eventId;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public int data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int eventId, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, int data=int.init) {
		this.eventId = eventId;
		this.position = position;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(eventId));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeBytes(varint.encode(data));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		eventId=varint.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		data=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe LevelEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		LevelEvent ret = new LevelEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "LevelEvent(eventId: " ~ std.conv.to!string(this.eventId) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class BlockEvent : Buffer {

	public enum ubyte ID = 28;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "data"];

	public sul.protocol.pocket100.types.BlockPosition position;
	public int[2] data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket100.types.BlockPosition position, int[2] data=(int[2]).init) {
		this.position = position;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		position.encode(bufferInstance);
		foreach(zgf0yq;data){ writeBytes(varint.encode(zgf0yq)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.decode(bufferInstance);
		foreach(ref zgf0yq;data){ zgf0yq=varint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe BlockEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		BlockEvent ret = new BlockEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "BlockEvent(position: " ~ std.conv.to!string(this.position) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class EntityEvent : Buffer {

	public enum ubyte ID = 29;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// event id
	public enum ubyte HURT_ANIMATION = 2;
	public enum ubyte DEATH_ANIMATION = 3;
	public enum ubyte TAME_FAIL = 6;
	public enum ubyte TAME_SUCCESS = 7;
	public enum ubyte SHAKE_WET = 8;
	public enum ubyte USE_ITEM = 9;
	public enum ubyte EAT_GRASS_ANIMATION = 10;
	public enum ubyte FISH_HOOK_BUBBLES = 11;
	public enum ubyte FISH_HOOK_POSITION = 12;
	public enum ubyte FISH_HOOK_HOOK = 13;
	public enum ubyte FISH_HOOK_TEASE = 14;
	public enum ubyte SQUID_INK_CLOUD = 15;
	public enum ubyte AMBIENT_SOUND = 16;
	public enum ubyte RESPAWN = 17;

	public enum string[] FIELDS = ["entityId", "eventId", "unknown2"];

	public long entityId;
	public ubyte eventId;
	public int unknown2;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, ubyte eventId=ubyte.init, int unknown2=int.init) {
		this.entityId = entityId;
		this.eventId = eventId;
		this.unknown2 = unknown2;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBigEndianUbyte(eventId);
		writeBytes(varint.encode(unknown2));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		eventId=readBigEndianUbyte();
		unknown2=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe EntityEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		EntityEvent ret = new EntityEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "EntityEvent(entityId: " ~ std.conv.to!string(this.entityId) ~ ", eventId: " ~ std.conv.to!string(this.eventId) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
	}

}

class MobEffect : Buffer {

	public enum ubyte ID = 30;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// event id
	public enum ubyte ADD = 1;
	public enum ubyte MODIFY = 2;
	public enum ubyte REMOVE = 3;

	public enum string[] FIELDS = ["entityId", "eventId", "effect", "amplifier", "particles", "duration"];

	public long entityId;
	public ubyte eventId;
	public int effect;
	public int amplifier;
	public bool particles;
	public int duration;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, ubyte eventId=ubyte.init, int effect=int.init, int amplifier=int.init, bool particles=bool.init, int duration=int.init) {
		this.entityId = entityId;
		this.eventId = eventId;
		this.effect = effect;
		this.amplifier = amplifier;
		this.particles = particles;
		this.duration = duration;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBigEndianUbyte(eventId);
		writeBytes(varint.encode(effect));
		writeBytes(varint.encode(amplifier));
		writeBigEndianBool(particles);
		writeBytes(varint.encode(duration));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		eventId=readBigEndianUbyte();
		effect=varint.decode(_buffer, &_index);
		amplifier=varint.decode(_buffer, &_index);
		particles=readBigEndianBool();
		duration=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe MobEffect fromBuffer(bool readId=true)(ubyte[] buffer) {
		MobEffect ret = new MobEffect();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MobEffect(entityId: " ~ std.conv.to!string(this.entityId) ~ ", eventId: " ~ std.conv.to!string(this.eventId) ~ ", effect: " ~ std.conv.to!string(this.effect) ~ ", amplifier: " ~ std.conv.to!string(this.amplifier) ~ ", particles: " ~ std.conv.to!string(this.particles) ~ ", duration: " ~ std.conv.to!string(this.duration) ~ ")";
	}

}

class UpdateAttributes : Buffer {

	public enum ubyte ID = 31;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "attributes"];

	public long entityId;
	public sul.protocol.pocket100.types.Attribute[] attributes;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, sul.protocol.pocket100.types.Attribute[] attributes=(sul.protocol.pocket100.types.Attribute[]).init) {
		this.entityId = entityId;
		this.attributes = attributes;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varuint.encode(cast(uint)attributes.length)); foreach(yxr0cmlidxrlcw;attributes){ yxr0cmlidxrlcw.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		attributes.length=varuint.decode(_buffer, &_index); foreach(ref yxr0cmlidxrlcw;attributes){ yxr0cmlidxrlcw.decode(bufferInstance); }
	}

	public static pure nothrow @safe UpdateAttributes fromBuffer(bool readId=true)(ubyte[] buffer) {
		UpdateAttributes ret = new UpdateAttributes();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "UpdateAttributes(entityId: " ~ std.conv.to!string(this.entityId) ~ ", attributes: " ~ std.conv.to!string(this.attributes) ~ ")";
	}

}

/**
 * Sent when the client puts an item in its hotbar or selects a new hotbar slot.
 */
class MobEquipment : Buffer {

	public enum ubyte ID = 32;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["entityId", "item", "inventorySlot", "hotbarSlot", "unknown4"];

	public long entityId;
	public sul.protocol.pocket100.types.Slot item;

	/**
	 * Slot of the inventory where the item is. The hotbat slots (0-8) are not counted.
	 * 255 means that a generic empty slot has been selected.
	 */
	public ubyte inventorySlot;

	/**
	 * Slot of the hotbar where the item is being moved.
	 */
	public ubyte hotbarSlot;
	public ubyte unknown4;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, sul.protocol.pocket100.types.Slot item=sul.protocol.pocket100.types.Slot.init, ubyte inventorySlot=ubyte.init, ubyte hotbarSlot=ubyte.init, ubyte unknown4=ubyte.init) {
		this.entityId = entityId;
		this.item = item;
		this.inventorySlot = inventorySlot;
		this.hotbarSlot = hotbarSlot;
		this.unknown4 = unknown4;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		item.encode(bufferInstance);
		writeBigEndianUbyte(inventorySlot);
		writeBigEndianUbyte(hotbarSlot);
		writeBigEndianUbyte(unknown4);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		item.decode(bufferInstance);
		inventorySlot=readBigEndianUbyte();
		hotbarSlot=readBigEndianUbyte();
		unknown4=readBigEndianUbyte();
	}

	public static pure nothrow @safe MobEquipment fromBuffer(bool readId=true)(ubyte[] buffer) {
		MobEquipment ret = new MobEquipment();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MobEquipment(entityId: " ~ std.conv.to!string(this.entityId) ~ ", item: " ~ std.conv.to!string(this.item) ~ ", inventorySlot: " ~ std.conv.to!string(this.inventorySlot) ~ ", hotbarSlot: " ~ std.conv.to!string(this.hotbarSlot) ~ ", unknown4: " ~ std.conv.to!string(this.unknown4) ~ ")";
	}

}

class MobArmorEquipment : Buffer {

	public enum ubyte ID = 33;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["entityId", "armor"];

	public long entityId;
	public sul.protocol.pocket100.types.Slot[4] armor;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, sul.protocol.pocket100.types.Slot[4] armor=(sul.protocol.pocket100.types.Slot[4]).init) {
		this.entityId = entityId;
		this.armor = armor;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		foreach(yxjtb3i;armor){ yxjtb3i.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		foreach(ref yxjtb3i;armor){ yxjtb3i.decode(bufferInstance); }
	}

	public static pure nothrow @safe MobArmorEquipment fromBuffer(bool readId=true)(ubyte[] buffer) {
		MobArmorEquipment ret = new MobArmorEquipment();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MobArmorEquipment(entityId: " ~ std.conv.to!string(this.entityId) ~ ", armor: " ~ std.conv.to!string(this.armor) ~ ")";
	}

}

class Interact : Buffer {

	public enum ubyte ID = 34;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// action
	public enum ubyte ATTACK = 1;
	public enum ubyte INTERACT = 2;
	public enum ubyte LEAVE_VEHICLE = 3;
	public enum ubyte HOVER = 4;

	public enum string[] FIELDS = ["action", "target"];

	public ubyte action;
	public long target;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte action, long target=long.init) {
		this.action = action;
		this.target = target;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(action);
		writeBytes(varlong.encode(target));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		action=readBigEndianUbyte();
		target=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe Interact fromBuffer(bool readId=true)(ubyte[] buffer) {
		Interact ret = new Interact();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Interact(action: " ~ std.conv.to!string(this.action) ~ ", target: " ~ std.conv.to!string(this.target) ~ ")";
	}

}

class UseItem : Buffer {

	public enum ubyte ID = 35;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["blockPosition", "hotbarSlot", "face", "facePosition", "position", "slot", "item"];

	public sul.protocol.pocket100.types.BlockPosition blockPosition;
	public uint hotbarSlot;
	public int face;
	public Tuple!(float, "x", float, "y", float, "z") facePosition;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public int slot;
	public sul.protocol.pocket100.types.Slot item;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket100.types.BlockPosition blockPosition, uint hotbarSlot=uint.init, int face=int.init, Tuple!(float, "x", float, "y", float, "z") facePosition=Tuple!(float, "x", float, "y", float, "z").init, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, int slot=int.init, sul.protocol.pocket100.types.Slot item=sul.protocol.pocket100.types.Slot.init) {
		this.blockPosition = blockPosition;
		this.hotbarSlot = hotbarSlot;
		this.face = face;
		this.facePosition = facePosition;
		this.position = position;
		this.slot = slot;
		this.item = item;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		blockPosition.encode(bufferInstance);
		writeBytes(varuint.encode(hotbarSlot));
		writeBytes(varint.encode(face));
		writeLittleEndianFloat(facePosition.x); writeLittleEndianFloat(facePosition.y); writeLittleEndianFloat(facePosition.z);
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeBytes(varint.encode(slot));
		item.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		blockPosition.decode(bufferInstance);
		hotbarSlot=varuint.decode(_buffer, &_index);
		face=varint.decode(_buffer, &_index);
		facePosition.x=readLittleEndianFloat(); facePosition.y=readLittleEndianFloat(); facePosition.z=readLittleEndianFloat();
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		slot=varint.decode(_buffer, &_index);
		item.decode(bufferInstance);
	}

	public static pure nothrow @safe UseItem fromBuffer(bool readId=true)(ubyte[] buffer) {
		UseItem ret = new UseItem();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "UseItem(blockPosition: " ~ std.conv.to!string(this.blockPosition) ~ ", hotbarSlot: " ~ std.conv.to!string(this.hotbarSlot) ~ ", face: " ~ std.conv.to!string(this.face) ~ ", facePosition: " ~ std.conv.to!string(this.facePosition) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", slot: " ~ std.conv.to!string(this.slot) ~ ", item: " ~ std.conv.to!string(this.item) ~ ")";
	}

}

class PlayerAction : Buffer {

	public enum ubyte ID = 36;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// action
	public enum int START_BREAK = 0;
	public enum int ABORT_BREAK = 1;
	public enum int STOP_BREAK = 2;
	public enum int RELEASE_ITEM = 5;
	public enum int STOP_SLEEPING = 6;
	public enum int RESPAWN = 7;
	public enum int JUMP = 8;
	public enum int START_SPRINT = 9;
	public enum int STOP_SPRINT = 10;
	public enum int START_SNEAK = 11;
	public enum int STOP_SNEAK = 12;
	public enum int START_GLIDING = 15;
	public enum int STOP_GLIDING = 16;

	public enum string[] FIELDS = ["entityId", "action", "position", "face"];

	public long entityId;
	public int action;
	public sul.protocol.pocket100.types.BlockPosition position;
	public int face;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, int action=int.init, sul.protocol.pocket100.types.BlockPosition position=sul.protocol.pocket100.types.BlockPosition.init, int face=int.init) {
		this.entityId = entityId;
		this.action = action;
		this.position = position;
		this.face = face;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varint.encode(action));
		position.encode(bufferInstance);
		writeBytes(varint.encode(face));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		action=varint.decode(_buffer, &_index);
		position.decode(bufferInstance);
		face=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe PlayerAction fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerAction ret = new PlayerAction();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerAction(entityId: " ~ std.conv.to!string(this.entityId) ~ ", action: " ~ std.conv.to!string(this.action) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", face: " ~ std.conv.to!string(this.face) ~ ")";
	}

}

class PlayerFall : Buffer {

	public enum ubyte ID = 37;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["distance"];

	public float distance;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(float distance) {
		this.distance = distance;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeLittleEndianFloat(distance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		distance=readLittleEndianFloat();
	}

	public static pure nothrow @safe PlayerFall fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerFall ret = new PlayerFall();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerFall(distance: " ~ std.conv.to!string(this.distance) ~ ")";
	}

}

class HurtArmor : Buffer {

	public enum ubyte ID = 38;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["health"];

	public int health;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int health) {
		this.health = health;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(health));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		health=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe HurtArmor fromBuffer(bool readId=true)(ubyte[] buffer) {
		HurtArmor ret = new HurtArmor();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "HurtArmor(health: " ~ std.conv.to!string(this.health) ~ ")";
	}

}

class SetEntityData : Buffer {

	public enum ubyte ID = 39;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "metadata"];

	public long entityId;
	public Metadata metadata;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, Metadata metadata=Metadata.init) {
		this.entityId = entityId;
		this.metadata = metadata;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		metadata.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		metadata=Metadata.decode(bufferInstance);
	}

	public static pure nothrow @safe SetEntityData fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetEntityData ret = new SetEntityData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetEntityData(entityId: " ~ std.conv.to!string(this.entityId) ~ ", metadata: " ~ std.conv.to!string(this.metadata) ~ ")";
	}

}

class SetEntityMotion : Buffer {

	public enum ubyte ID = 40;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "motion"];

	public long entityId;
	public Tuple!(float, "x", float, "y", float, "z") motion;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, Tuple!(float, "x", float, "y", float, "z") motion=Tuple!(float, "x", float, "y", float, "z").init) {
		this.entityId = entityId;
		this.motion = motion;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeLittleEndianFloat(motion.x); writeLittleEndianFloat(motion.y); writeLittleEndianFloat(motion.z);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		motion.x=readLittleEndianFloat(); motion.y=readLittleEndianFloat(); motion.z=readLittleEndianFloat();
	}

	public static pure nothrow @safe SetEntityMotion fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetEntityMotion ret = new SetEntityMotion();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetEntityMotion(entityId: " ~ std.conv.to!string(this.entityId) ~ ", motion: " ~ std.conv.to!string(this.motion) ~ ")";
	}

}

class SetEntityLink : Buffer {

	public enum ubyte ID = 41;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum ubyte ADD = 0;
	public enum ubyte REMOVE = 1;

	public enum string[] FIELDS = ["from", "to", "action"];

	public long from;
	public long to;
	public ubyte action;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long from, long to=long.init, ubyte action=ubyte.init) {
		this.from = from;
		this.to = to;
		this.action = action;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(from));
		writeBytes(varlong.encode(to));
		writeBigEndianUbyte(action);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		from=varlong.decode(_buffer, &_index);
		to=varlong.decode(_buffer, &_index);
		action=readBigEndianUbyte();
	}

	public static pure nothrow @safe SetEntityLink fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetEntityLink ret = new SetEntityLink();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetEntityLink(from: " ~ std.conv.to!string(this.from) ~ ", to: " ~ std.conv.to!string(this.to) ~ ", action: " ~ std.conv.to!string(this.action) ~ ")";
	}

}

class SetHealth : Buffer {

	public enum ubyte ID = 42;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["health"];

	public int health;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int health) {
		this.health = health;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(health));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		health=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SetHealth fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetHealth ret = new SetHealth();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetHealth(health: " ~ std.conv.to!string(this.health) ~ ")";
	}

}

class SetSpawnPosition : Buffer {

	public enum ubyte ID = 43;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["unknown0", "position", "unknown2"];

	public int unknown0;
	public sul.protocol.pocket100.types.BlockPosition position;
	public bool unknown2;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int unknown0, sul.protocol.pocket100.types.BlockPosition position=sul.protocol.pocket100.types.BlockPosition.init, bool unknown2=bool.init) {
		this.unknown0 = unknown0;
		this.position = position;
		this.unknown2 = unknown2;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(unknown0));
		position.encode(bufferInstance);
		writeBigEndianBool(unknown2);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		unknown0=varint.decode(_buffer, &_index);
		position.decode(bufferInstance);
		unknown2=readBigEndianBool();
	}

	public static pure nothrow @safe SetSpawnPosition fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetSpawnPosition ret = new SetSpawnPosition();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetSpawnPosition(unknown0: " ~ std.conv.to!string(this.unknown0) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
	}

}

class Animate : Buffer {

	public enum ubyte ID = 44;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// action
	public enum int BREAKING = 1;
	public enum int WAKE_UP = 3;

	public enum string[] FIELDS = ["action", "entityId"];

	public int action;
	public long entityId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int action, long entityId=long.init) {
		this.action = action;
		this.entityId = entityId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(action));
		writeBytes(varlong.encode(entityId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		action=varint.decode(_buffer, &_index);
		entityId=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe Animate fromBuffer(bool readId=true)(ubyte[] buffer) {
		Animate ret = new Animate();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Animate(action: " ~ std.conv.to!string(this.action) ~ ", entityId: " ~ std.conv.to!string(this.entityId) ~ ")";
	}

}

class Respawn : Buffer {

	public enum ubyte ID = 45;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position"];

	public Tuple!(float, "x", float, "y", float, "z") position;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(float, "x", float, "y", float, "z") position) {
		this.position = position;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
	}

	public static pure nothrow @safe Respawn fromBuffer(bool readId=true)(ubyte[] buffer) {
		Respawn ret = new Respawn();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Respawn(position: " ~ std.conv.to!string(this.position) ~ ")";
	}

}

class DropItem : Buffer {

	public enum ubyte ID = 46;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	// action
	public enum ubyte DROP = 0;

	public enum string[] FIELDS = ["action", "item"];

	public ubyte action;
	public sul.protocol.pocket100.types.Slot item;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte action, sul.protocol.pocket100.types.Slot item=sul.protocol.pocket100.types.Slot.init) {
		this.action = action;
		this.item = item;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(action);
		item.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		action=readBigEndianUbyte();
		item.decode(bufferInstance);
	}

	public static pure nothrow @safe DropItem fromBuffer(bool readId=true)(ubyte[] buffer) {
		DropItem ret = new DropItem();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "DropItem(action: " ~ std.conv.to!string(this.action) ~ ", item: " ~ std.conv.to!string(this.item) ~ ")";
	}

}

class InventoryAction : Buffer {

	public enum ubyte ID = 47;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["action", "item"];

	public int action;
	public sul.protocol.pocket100.types.Slot item;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int action, sul.protocol.pocket100.types.Slot item=sul.protocol.pocket100.types.Slot.init) {
		this.action = action;
		this.item = item;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(action));
		item.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		action=varint.decode(_buffer, &_index);
		item.decode(bufferInstance);
	}

	public static pure nothrow @safe InventoryAction fromBuffer(bool readId=true)(ubyte[] buffer) {
		InventoryAction ret = new InventoryAction();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "InventoryAction(action: " ~ std.conv.to!string(this.action) ~ ", item: " ~ std.conv.to!string(this.item) ~ ")";
	}

}

class ContainerOpen : Buffer {

	public enum ubyte ID = 48;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["window", "type", "slotCount", "position", "entityId"];

	public ubyte window;
	public ubyte type;
	public int slotCount;
	public sul.protocol.pocket100.types.BlockPosition position;
	public long entityId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, ubyte type=ubyte.init, int slotCount=int.init, sul.protocol.pocket100.types.BlockPosition position=sul.protocol.pocket100.types.BlockPosition.init, long entityId=long.init) {
		this.window = window;
		this.type = type;
		this.slotCount = slotCount;
		this.position = position;
		this.entityId = entityId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(window);
		writeBigEndianUbyte(type);
		writeBytes(varint.encode(slotCount));
		position.encode(bufferInstance);
		writeBytes(varlong.encode(entityId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		window=readBigEndianUbyte();
		type=readBigEndianUbyte();
		slotCount=varint.decode(_buffer, &_index);
		position.decode(bufferInstance);
		entityId=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe ContainerOpen fromBuffer(bool readId=true)(ubyte[] buffer) {
		ContainerOpen ret = new ContainerOpen();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ContainerOpen(window: " ~ std.conv.to!string(this.window) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", slotCount: " ~ std.conv.to!string(this.slotCount) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", entityId: " ~ std.conv.to!string(this.entityId) ~ ")";
	}

}

class ContainerClose : Buffer {

	public enum ubyte ID = 49;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["window"];

	public ubyte window;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window) {
		this.window = window;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(window);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		window=readBigEndianUbyte();
	}

	public static pure nothrow @safe ContainerClose fromBuffer(bool readId=true)(ubyte[] buffer) {
		ContainerClose ret = new ContainerClose();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ContainerClose(window: " ~ std.conv.to!string(this.window) ~ ")";
	}

}

class ContainerSetSlot : Buffer {

	public enum ubyte ID = 50;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["window", "slot", "hotbarSlot", "item", "unknown4"];

	public ubyte window;
	public int slot;
	public int hotbarSlot;
	public sul.protocol.pocket100.types.Slot item;
	public ubyte unknown4;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, int slot=int.init, int hotbarSlot=int.init, sul.protocol.pocket100.types.Slot item=sul.protocol.pocket100.types.Slot.init, ubyte unknown4=ubyte.init) {
		this.window = window;
		this.slot = slot;
		this.hotbarSlot = hotbarSlot;
		this.item = item;
		this.unknown4 = unknown4;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(window);
		writeBytes(varint.encode(slot));
		writeBytes(varint.encode(hotbarSlot));
		item.encode(bufferInstance);
		writeBigEndianUbyte(unknown4);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		window=readBigEndianUbyte();
		slot=varint.decode(_buffer, &_index);
		hotbarSlot=varint.decode(_buffer, &_index);
		item.decode(bufferInstance);
		unknown4=readBigEndianUbyte();
	}

	public static pure nothrow @safe ContainerSetSlot fromBuffer(bool readId=true)(ubyte[] buffer) {
		ContainerSetSlot ret = new ContainerSetSlot();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ContainerSetSlot(window: " ~ std.conv.to!string(this.window) ~ ", slot: " ~ std.conv.to!string(this.slot) ~ ", hotbarSlot: " ~ std.conv.to!string(this.hotbarSlot) ~ ", item: " ~ std.conv.to!string(this.item) ~ ", unknown4: " ~ std.conv.to!string(this.unknown4) ~ ")";
	}

}

class ContainerSetData : Buffer {

	public enum ubyte ID = 51;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["window", "property", "value"];

	public ubyte window;
	public int property;
	public int value;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, int property=int.init, int value=int.init) {
		this.window = window;
		this.property = property;
		this.value = value;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(window);
		writeBytes(varint.encode(property));
		writeBytes(varint.encode(value));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		window=readBigEndianUbyte();
		property=varint.decode(_buffer, &_index);
		value=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe ContainerSetData fromBuffer(bool readId=true)(ubyte[] buffer) {
		ContainerSetData ret = new ContainerSetData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ContainerSetData(window: " ~ std.conv.to!string(this.window) ~ ", property: " ~ std.conv.to!string(this.property) ~ ", value: " ~ std.conv.to!string(this.value) ~ ")";
	}

}

class ContainerSetContent : Buffer {

	public enum ubyte ID = 52;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["window", "slots", "hotbar"];

	public ubyte window;
	public sul.protocol.pocket100.types.Slot[] slots;
	public int[] hotbar;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, sul.protocol.pocket100.types.Slot[] slots=(sul.protocol.pocket100.types.Slot[]).init, int[] hotbar=(int[]).init) {
		this.window = window;
		this.slots = slots;
		this.hotbar = hotbar;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(window);
		writeBytes(varuint.encode(cast(uint)slots.length)); foreach(c2xvdhm;slots){ c2xvdhm.encode(bufferInstance); }
		writeBytes(varuint.encode(cast(uint)hotbar.length)); foreach(ag90ymfy;hotbar){ writeBytes(varint.encode(ag90ymfy)); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		window=readBigEndianUbyte();
		slots.length=varuint.decode(_buffer, &_index); foreach(ref c2xvdhm;slots){ c2xvdhm.decode(bufferInstance); }
		hotbar.length=varuint.decode(_buffer, &_index); foreach(ref ag90ymfy;hotbar){ ag90ymfy=varint.decode(_buffer, &_index); }
	}

	public static pure nothrow @safe ContainerSetContent fromBuffer(bool readId=true)(ubyte[] buffer) {
		ContainerSetContent ret = new ContainerSetContent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ContainerSetContent(window: " ~ std.conv.to!string(this.window) ~ ", slots: " ~ std.conv.to!string(this.slots) ~ ", hotbar: " ~ std.conv.to!string(this.hotbar) ~ ")";
	}

}

class CraftingData : Buffer {

	public enum ubyte ID = 53;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["recipes"];

	public sul.protocol.pocket100.types.Recipe[] recipes;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket100.types.Recipe[] recipes) {
		this.recipes = recipes;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)recipes.length)); foreach(cmvjaxblcw;recipes){ cmvjaxblcw.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		recipes.length=varuint.decode(_buffer, &_index); foreach(ref cmvjaxblcw;recipes){ cmvjaxblcw.decode(bufferInstance); }
	}

	public static pure nothrow @safe CraftingData fromBuffer(bool readId=true)(ubyte[] buffer) {
		CraftingData ret = new CraftingData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "CraftingData(recipes: " ~ std.conv.to!string(this.recipes) ~ ")";
	}

}

class CraftingEvent : Buffer {

	public enum ubyte ID = 54;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["window", "type", "uuid", "input", "output"];

	public ubyte window;
	public int type;
	public UUID uuid;
	public sul.protocol.pocket100.types.Slot[] input;
	public sul.protocol.pocket100.types.Slot[] output;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte window, int type=int.init, UUID uuid=UUID.init, sul.protocol.pocket100.types.Slot[] input=(sul.protocol.pocket100.types.Slot[]).init, sul.protocol.pocket100.types.Slot[] output=(sul.protocol.pocket100.types.Slot[]).init) {
		this.window = window;
		this.type = type;
		this.uuid = uuid;
		this.input = input;
		this.output = output;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(window);
		writeBytes(varint.encode(type));
		writeBytes(uuid.data);
		writeBytes(varuint.encode(cast(uint)input.length)); foreach(aw5wdxq;input){ aw5wdxq.encode(bufferInstance); }
		writeBytes(varuint.encode(cast(uint)output.length)); foreach(b3v0chv0;output){ b3v0chv0.encode(bufferInstance); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		window=readBigEndianUbyte();
		type=varint.decode(_buffer, &_index);
		if(_buffer.length>=_index+16){ ubyte[16] dxvpza=_buffer[_index.._index+16].dup; _index+=16; uuid=UUID(dxvpza); }
		input.length=varuint.decode(_buffer, &_index); foreach(ref aw5wdxq;input){ aw5wdxq.decode(bufferInstance); }
		output.length=varuint.decode(_buffer, &_index); foreach(ref b3v0chv0;output){ b3v0chv0.decode(bufferInstance); }
	}

	public static pure nothrow @safe CraftingEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		CraftingEvent ret = new CraftingEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "CraftingEvent(window: " ~ std.conv.to!string(this.window) ~ ", type: " ~ std.conv.to!string(this.type) ~ ", uuid: " ~ std.conv.to!string(this.uuid) ~ ", input: " ~ std.conv.to!string(this.input) ~ ", output: " ~ std.conv.to!string(this.output) ~ ")";
	}

}

class AdventureSettings : Buffer {

	public enum ubyte ID = 55;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// flags
	public enum uint IMMUTABLE_WORLD = 1;
	public enum uint PVP_DISABLED = 2;
	public enum uint PVM_DISABLED = 4;
	public enum uint MVP_DISBALED = 8;
	public enum uint EVP_DISABLED = 16;
	public enum uint AUTO_JUMP = 32;
	public enum uint ALLOW_FLIGHT = 64;
	public enum uint NO_CLIP = 128;
	public enum uint FLYING = 256;

	// permissions
	public enum uint USER = 0;
	public enum uint OPERATOR = 1;
	public enum uint HOST = 2;
	public enum uint AUTOMATION = 3;
	public enum uint ADMIN = 4;

	public enum string[] FIELDS = ["flags", "permissions"];

	public uint flags;
	public uint permissions;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint flags, uint permissions=uint.init) {
		this.flags = flags;
		this.permissions = permissions;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(flags));
		writeBytes(varuint.encode(permissions));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		flags=varuint.decode(_buffer, &_index);
		permissions=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe AdventureSettings fromBuffer(bool readId=true)(ubyte[] buffer) {
		AdventureSettings ret = new AdventureSettings();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AdventureSettings(flags: " ~ std.conv.to!string(this.flags) ~ ", permissions: " ~ std.conv.to!string(this.permissions) ~ ")";
	}

}

class BlockEntityData : Buffer {

	public enum ubyte ID = 56;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "nbt"];

	public sul.protocol.pocket100.types.BlockPosition position;
	public ubyte[] nbt;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket100.types.BlockPosition position, ubyte[] nbt=(ubyte[]).init) {
		this.position = position;
		this.nbt = nbt;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		position.encode(bufferInstance);
		writeBytes(nbt);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.decode(bufferInstance);
		nbt=_buffer[_index..$].dup; _index=_buffer.length;
	}

	public static pure nothrow @safe BlockEntityData fromBuffer(bool readId=true)(ubyte[] buffer) {
		BlockEntityData ret = new BlockEntityData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "BlockEntityData(position: " ~ std.conv.to!string(this.position) ~ ", nbt: " ~ std.conv.to!string(this.nbt) ~ ")";
	}

}

class PlayerInput : Buffer {

	public enum ubyte ID = 57;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["motion", "flags", "unknown2"];

	public Tuple!(float, "x", float, "y", float, "z") motion;
	public ubyte flags;
	public bool unknown2;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(float, "x", float, "y", float, "z") motion, ubyte flags=ubyte.init, bool unknown2=bool.init) {
		this.motion = motion;
		this.flags = flags;
		this.unknown2 = unknown2;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeLittleEndianFloat(motion.x); writeLittleEndianFloat(motion.y); writeLittleEndianFloat(motion.z);
		writeBigEndianUbyte(flags);
		writeBigEndianBool(unknown2);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		motion.x=readLittleEndianFloat(); motion.y=readLittleEndianFloat(); motion.z=readLittleEndianFloat();
		flags=readBigEndianUbyte();
		unknown2=readBigEndianBool();
	}

	public static pure nothrow @safe PlayerInput fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerInput ret = new PlayerInput();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerInput(motion: " ~ std.conv.to!string(this.motion) ~ ", flags: " ~ std.conv.to!string(this.flags) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
	}

}

class FullChunkData : Buffer {

	public enum ubyte ID = 58;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "data", "tiles"];

	public Tuple!(int, "x", int, "z") position;
	public ubyte[] data;
	public ubyte[] tiles;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(int, "x", int, "z") position, ubyte[] data=(ubyte[]).init, ubyte[] tiles=(ubyte[]).init) {
		this.position = position;
		this.data = data;
		this.tiles = tiles;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(position.x)); writeBytes(varint.encode(position.z));
		writeBytes(varuint.encode(cast(uint)data.length)); writeBytes(data);
		writeBytes(varuint.encode(cast(uint)tiles.length)); writeBytes(tiles);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.x=varint.decode(_buffer, &_index); position.z=varint.decode(_buffer, &_index);
		data.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+data.length){ data=_buffer[_index.._index+data.length].dup; _index+=data.length; }
		tiles.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+tiles.length){ tiles=_buffer[_index.._index+tiles.length].dup; _index+=tiles.length; }
	}

	public static pure nothrow @safe FullChunkData fromBuffer(bool readId=true)(ubyte[] buffer) {
		FullChunkData ret = new FullChunkData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "FullChunkData(position: " ~ std.conv.to!string(this.position) ~ ", data: " ~ std.conv.to!string(this.data) ~ ", tiles: " ~ std.conv.to!string(this.tiles) ~ ")";
	}

}

class SetCheatsEnabled : Buffer {

	public enum ubyte ID = 59;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["enabled"];

	public bool enabled;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(bool enabled) {
		this.enabled = enabled;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianBool(enabled);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		enabled=readBigEndianBool();
	}

	public static pure nothrow @safe SetCheatsEnabled fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetCheatsEnabled ret = new SetCheatsEnabled();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetCheatsEnabled(enabled: " ~ std.conv.to!string(this.enabled) ~ ")";
	}

}

class SetDifficulty : Buffer {

	public enum ubyte ID = 60;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// difficulty
	public enum uint PEACEFUL = 0;
	public enum uint EASY = 1;
	public enum uint NORMAL = 2;
	public enum uint HARD = 3;

	public enum string[] FIELDS = ["difficulty"];

	public uint difficulty;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(uint difficulty) {
		this.difficulty = difficulty;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(difficulty));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		difficulty=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SetDifficulty fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetDifficulty ret = new SetDifficulty();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetDifficulty(difficulty: " ~ std.conv.to!string(this.difficulty) ~ ")";
	}

}

class ChangeDimension : Buffer {

	public enum ubyte ID = 61;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// dimension
	public enum int OVERWORLD = 0;
	public enum int NETHER = 1;
	public enum int END = 2;

	public enum string[] FIELDS = ["dimension", "position", "unknown2"];

	public int dimension;
	public Tuple!(float, "x", float, "y", float, "z") position;
	public bool unknown2;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int dimension, Tuple!(float, "x", float, "y", float, "z") position=Tuple!(float, "x", float, "y", float, "z").init, bool unknown2=bool.init) {
		this.dimension = dimension;
		this.position = position;
		this.unknown2 = unknown2;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(dimension));
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeBigEndianBool(unknown2);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		dimension=varint.decode(_buffer, &_index);
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		unknown2=readBigEndianBool();
	}

	public static pure nothrow @safe ChangeDimension fromBuffer(bool readId=true)(ubyte[] buffer) {
		ChangeDimension ret = new ChangeDimension();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ChangeDimension(dimension: " ~ std.conv.to!string(this.dimension) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ")";
	}

}

class SetPlayerGametype : Buffer {

	public enum ubyte ID = 62;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	// gametype
	public enum int SURVIVAL = 0;
	public enum int CREATIVE = 1;

	public enum string[] FIELDS = ["gametype"];

	public int gametype;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int gametype) {
		this.gametype = gametype;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(gametype));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		gametype=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SetPlayerGametype fromBuffer(bool readId=true)(ubyte[] buffer) {
		SetPlayerGametype ret = new SetPlayerGametype();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SetPlayerGametype(gametype: " ~ std.conv.to!string(this.gametype) ~ ")";
	}

}

class PlayerList : Buffer {

	public enum ubyte ID = 63;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["action"];

	public ubyte action;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(ubyte action) {
		this.action = action;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBigEndianUbyte(action);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		action=readBigEndianUbyte();
	}

	public static pure nothrow @safe PlayerList fromBuffer(bool readId=true)(ubyte[] buffer) {
		PlayerList ret = new PlayerList();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "PlayerList(action: " ~ std.conv.to!string(this.action) ~ ")";
	}

	alias _encode = encode;

	enum string variantField = "action";

	alias Variants = TypeTuple!(Add, Remove);

	public class Add {

		public enum typeof(action) ACTION = 0;

		public enum string[] FIELDS = ["players"];

		public sul.protocol.pocket100.types.PlayerList[] players;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(sul.protocol.pocket100.types.PlayerList[] players) {
			this.players = players;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 0;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)players.length)); foreach(cgxhewvycw;players){ cgxhewvycw.encode(bufferInstance); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			players.length=varuint.decode(_buffer, &_index); foreach(ref cgxhewvycw;players){ cgxhewvycw.decode(bufferInstance); }
		}

		public override string toString() {
			return "PlayerList.Add(players: " ~ std.conv.to!string(this.players) ~ ")";
		}

	}

	public class Remove {

		public enum typeof(action) ACTION = 1;

		public enum string[] FIELDS = ["players"];

		public UUID[] players;

		public pure nothrow @safe @nogc this() {}

		public pure nothrow @safe @nogc this(UUID[] players) {
			this.players = players;
		}

		public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
			action = 1;
			_encode!writeId();
			writeBytes(varuint.encode(cast(uint)players.length)); foreach(cgxhewvycw;players){ writeBytes(cgxhewvycw.data); }
			return _buffer;
		}

		public pure nothrow @safe void decode() {
			players.length=varuint.decode(_buffer, &_index); foreach(ref cgxhewvycw;players){ if(_buffer.length>=_index+16){ ubyte[16] y2d4agv3dnljdw=_buffer[_index.._index+16].dup; _index+=16; cgxhewvycw=UUID(y2d4agv3dnljdw); } }
		}

		public override string toString() {
			return "PlayerList.Remove(players: " ~ std.conv.to!string(this.players) ~ ")";
		}

	}

}

class TelemetryEvent : Buffer {

	public enum ubyte ID = 64;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["entityId", "eventId"];

	public long entityId;
	public int eventId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, int eventId=int.init) {
		this.entityId = entityId;
		this.eventId = eventId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varint.encode(eventId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		eventId=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe TelemetryEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		TelemetryEvent ret = new TelemetryEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "TelemetryEvent(entityId: " ~ std.conv.to!string(this.entityId) ~ ", eventId: " ~ std.conv.to!string(this.eventId) ~ ")";
	}

}

class SpawnExperienceOrb : Buffer {

	public enum ubyte ID = 65;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "count"];

	public Tuple!(float, "x", float, "y", float, "z") position;
	public int count;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(Tuple!(float, "x", float, "y", float, "z") position, int count=int.init) {
		this.position = position;
		this.count = count;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeLittleEndianFloat(position.x); writeLittleEndianFloat(position.y); writeLittleEndianFloat(position.z);
		writeBytes(varint.encode(count));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.x=readLittleEndianFloat(); position.y=readLittleEndianFloat(); position.z=readLittleEndianFloat();
		count=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe SpawnExperienceOrb fromBuffer(bool readId=true)(ubyte[] buffer) {
		SpawnExperienceOrb ret = new SpawnExperienceOrb();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "SpawnExperienceOrb(position: " ~ std.conv.to!string(this.position) ~ ", count: " ~ std.conv.to!string(this.count) ~ ")";
	}

}

class ClientboundMapItemData : Buffer {

	public enum ubyte ID = 66;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// action
	public enum ubyte UPDATE = 4;
	public enum ubyte FULL = 6;

	public enum string[] FIELDS = ["mapId", "unknown1", "unknown2", "unknown3", "action", "unknown5", "unknown6", "unknown7", "unknown8", "showIcons", "icons", "direction", "position", "columns", "rows", "offset", "data"];

	public long mapId;
	public uint unknown1;
	public uint unknown2;
	public long unknown3;
	public ubyte action;
	public uint unknown5;
	public int unknown6;
	public byte unknown7;
	public byte unknown8;
	public bool showIcons;
	public Tuple!(int, "x", int, "z")[] icons;
	public int direction;
	public Tuple!(int, "x", int, "z") position;
	public int columns;
	public int rows;
	public Tuple!(int, "x", int, "z") offset;
	public ubyte[] data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long mapId, uint unknown1=uint.init, uint unknown2=uint.init, long unknown3=long.init, ubyte action=ubyte.init, uint unknown5=uint.init, int unknown6=int.init, byte unknown7=byte.init, byte unknown8=byte.init, bool showIcons=bool.init, Tuple!(int, "x", int, "z")[] icons=(Tuple!(int, "x", int, "z")[]).init, int direction=int.init, Tuple!(int, "x", int, "z") position=Tuple!(int, "x", int, "z").init, int columns=int.init, int rows=int.init, Tuple!(int, "x", int, "z") offset=Tuple!(int, "x", int, "z").init, ubyte[] data=(ubyte[]).init) {
		this.mapId = mapId;
		this.unknown1 = unknown1;
		this.unknown2 = unknown2;
		this.unknown3 = unknown3;
		this.action = action;
		this.unknown5 = unknown5;
		this.unknown6 = unknown6;
		this.unknown7 = unknown7;
		this.unknown8 = unknown8;
		this.showIcons = showIcons;
		this.icons = icons;
		this.direction = direction;
		this.position = position;
		this.columns = columns;
		this.rows = rows;
		this.offset = offset;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(mapId));
		writeBytes(varuint.encode(unknown1));
		writeBytes(varuint.encode(unknown2));
		writeBytes(varlong.encode(unknown3));
		writeBigEndianUbyte(action);
		writeBytes(varuint.encode(unknown5));
		writeBytes(varint.encode(unknown6));
		writeBigEndianByte(unknown7);
		writeBigEndianByte(unknown8);
		writeBigEndianBool(showIcons);
		writeBytes(varuint.encode(cast(uint)icons.length)); foreach(awnvbnm;icons){ writeBytes(varint.encode(awnvbnm.x)); writeBytes(varint.encode(awnvbnm.z)); }
		writeBytes(varint.encode(direction));
		writeBytes(varint.encode(position.x)); writeBytes(varint.encode(position.z));
		writeBytes(varint.encode(columns));
		writeBytes(varint.encode(rows));
		writeBytes(varint.encode(offset.x)); writeBytes(varint.encode(offset.z));
		writeBytes(varuint.encode(cast(uint)data.length)); writeBytes(data);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		mapId=varlong.decode(_buffer, &_index);
		unknown1=varuint.decode(_buffer, &_index);
		unknown2=varuint.decode(_buffer, &_index);
		unknown3=varlong.decode(_buffer, &_index);
		action=readBigEndianUbyte();
		unknown5=varuint.decode(_buffer, &_index);
		unknown6=varint.decode(_buffer, &_index);
		unknown7=readBigEndianByte();
		unknown8=readBigEndianByte();
		showIcons=readBigEndianBool();
		icons.length=varuint.decode(_buffer, &_index); foreach(ref awnvbnm;icons){ awnvbnm.x=varint.decode(_buffer, &_index); awnvbnm.z=varint.decode(_buffer, &_index); }
		direction=varint.decode(_buffer, &_index);
		position.x=varint.decode(_buffer, &_index); position.z=varint.decode(_buffer, &_index);
		columns=varint.decode(_buffer, &_index);
		rows=varint.decode(_buffer, &_index);
		offset.x=varint.decode(_buffer, &_index); offset.z=varint.decode(_buffer, &_index);
		data.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+data.length){ data=_buffer[_index.._index+data.length].dup; _index+=data.length; }
	}

	public static pure nothrow @safe ClientboundMapItemData fromBuffer(bool readId=true)(ubyte[] buffer) {
		ClientboundMapItemData ret = new ClientboundMapItemData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ClientboundMapItemData(mapId: " ~ std.conv.to!string(this.mapId) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ", unknown3: " ~ std.conv.to!string(this.unknown3) ~ ", action: " ~ std.conv.to!string(this.action) ~ ", unknown5: " ~ std.conv.to!string(this.unknown5) ~ ", unknown6: " ~ std.conv.to!string(this.unknown6) ~ ", unknown7: " ~ std.conv.to!string(this.unknown7) ~ ", unknown8: " ~ std.conv.to!string(this.unknown8) ~ ", showIcons: " ~ std.conv.to!string(this.showIcons) ~ ", icons: " ~ std.conv.to!string(this.icons) ~ ", direction: " ~ std.conv.to!string(this.direction) ~ ", position: " ~ std.conv.to!string(this.position) ~ ", columns: " ~ std.conv.to!string(this.columns) ~ ", rows: " ~ std.conv.to!string(this.rows) ~ ", offset: " ~ std.conv.to!string(this.offset) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class MapInfoRequest : Buffer {

	public enum ubyte ID = 67;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["mapId"];

	public long mapId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long mapId) {
		this.mapId = mapId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(mapId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		mapId=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe MapInfoRequest fromBuffer(bool readId=true)(ubyte[] buffer) {
		MapInfoRequest ret = new MapInfoRequest();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "MapInfoRequest(mapId: " ~ std.conv.to!string(this.mapId) ~ ")";
	}

}

class RequestChunkRadius : Buffer {

	public enum ubyte ID = 68;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["radius"];

	public int radius;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int radius) {
		this.radius = radius;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(radius));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		radius=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe RequestChunkRadius fromBuffer(bool readId=true)(ubyte[] buffer) {
		RequestChunkRadius ret = new RequestChunkRadius();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "RequestChunkRadius(radius: " ~ std.conv.to!string(this.radius) ~ ")";
	}

}

class ChunkRadiusUpdated : Buffer {

	public enum ubyte ID = 69;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["radius"];

	public int radius;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(int radius) {
		this.radius = radius;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varint.encode(radius));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		radius=varint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe ChunkRadiusUpdated fromBuffer(bool readId=true)(ubyte[] buffer) {
		ChunkRadiusUpdated ret = new ChunkRadiusUpdated();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ChunkRadiusUpdated(radius: " ~ std.conv.to!string(this.radius) ~ ")";
	}

}

class ItemFrameDropItem : Buffer {

	public enum ubyte ID = 70;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["position", "item"];

	public sul.protocol.pocket100.types.BlockPosition position;
	public sul.protocol.pocket100.types.Slot item;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket100.types.BlockPosition position, sul.protocol.pocket100.types.Slot item=sul.protocol.pocket100.types.Slot.init) {
		this.position = position;
		this.item = item;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		position.encode(bufferInstance);
		item.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		position.decode(bufferInstance);
		item.decode(bufferInstance);
	}

	public static pure nothrow @safe ItemFrameDropItem fromBuffer(bool readId=true)(ubyte[] buffer) {
		ItemFrameDropItem ret = new ItemFrameDropItem();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ItemFrameDropItem(position: " ~ std.conv.to!string(this.position) ~ ", item: " ~ std.conv.to!string(this.item) ~ ")";
	}

}

class ReplaceSelectedItem : Buffer {

	public enum ubyte ID = 71;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["item"];

	public sul.protocol.pocket100.types.Slot item;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket100.types.Slot item) {
		this.item = item;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		item.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		item.decode(bufferInstance);
	}

	public static pure nothrow @safe ReplaceSelectedItem fromBuffer(bool readId=true)(ubyte[] buffer) {
		ReplaceSelectedItem ret = new ReplaceSelectedItem();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ReplaceSelectedItem(item: " ~ std.conv.to!string(this.item) ~ ")";
	}

}

class Camera : Buffer {

	public enum ubyte ID = 73;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["unknown0", "unknown1"];

	public long unknown0;
	public long unknown1;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long unknown0, long unknown1=long.init) {
		this.unknown0 = unknown0;
		this.unknown1 = unknown1;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(unknown0));
		writeBytes(varlong.encode(unknown1));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		unknown0=varlong.decode(_buffer, &_index);
		unknown1=varlong.decode(_buffer, &_index);
	}

	public static pure nothrow @safe Camera fromBuffer(bool readId=true)(ubyte[] buffer) {
		Camera ret = new Camera();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "Camera(unknown0: " ~ std.conv.to!string(this.unknown0) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ")";
	}

}

class AddItem : Buffer {

	public enum ubyte ID = 74;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["item"];

	public sul.protocol.pocket100.types.Slot item;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(sul.protocol.pocket100.types.Slot item) {
		this.item = item;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		item.encode(bufferInstance);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		item.decode(bufferInstance);
	}

	public static pure nothrow @safe AddItem fromBuffer(bool readId=true)(ubyte[] buffer) {
		AddItem ret = new AddItem();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AddItem(item: " ~ std.conv.to!string(this.item) ~ ")";
	}

}

class BossEvent : Buffer {

	public enum ubyte ID = 75;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	// event id
	public enum uint ADD = 0;
	public enum uint UPDATE = 1;
	public enum uint REMOVE = 2;

	public enum string[] FIELDS = ["entityId", "eventId"];

	public long entityId;
	public uint eventId;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(long entityId, uint eventId=uint.init) {
		this.entityId = entityId;
		this.eventId = eventId;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varlong.encode(entityId));
		writeBytes(varuint.encode(eventId));
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		entityId=varlong.decode(_buffer, &_index);
		eventId=varuint.decode(_buffer, &_index);
	}

	public static pure nothrow @safe BossEvent fromBuffer(bool readId=true)(ubyte[] buffer) {
		BossEvent ret = new BossEvent();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "BossEvent(entityId: " ~ std.conv.to!string(this.entityId) ~ ", eventId: " ~ std.conv.to!string(this.eventId) ~ ")";
	}

}

class ShowCredits : Buffer {

	public enum ubyte ID = 76;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = [];

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
	}

	public static pure nothrow @safe ShowCredits fromBuffer(bool readId=true)(ubyte[] buffer) {
		ShowCredits ret = new ShowCredits();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ShowCredits()";
	}

}

class AvailableCommands : Buffer {

	public enum ubyte ID = 77;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["commands", "unknown1"];

	public string commands;
	public string unknown1;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string commands, string unknown1=string.init) {
		this.commands = commands;
		this.unknown1 = unknown1;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)commands.length)); writeString(commands);
		writeBytes(varuint.encode(cast(uint)unknown1.length)); writeString(unknown1);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		uint y29tbwfuzhm=varuint.decode(_buffer, &_index); commands=readString(y29tbwfuzhm);
		uint dw5rbm93bje=varuint.decode(_buffer, &_index); unknown1=readString(dw5rbm93bje);
	}

	public static pure nothrow @safe AvailableCommands fromBuffer(bool readId=true)(ubyte[] buffer) {
		AvailableCommands ret = new AvailableCommands();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "AvailableCommands(commands: " ~ std.conv.to!string(this.commands) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ")";
	}

}

class CommandStep : Buffer {

	public enum ubyte ID = 78;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["command", "overload", "unknown2", "unknown3", "isOutput", "unknown5", "input", "output"];

	public string command;
	public string overload;
	public uint unknown2;
	public uint unknown3;
	public bool isOutput;
	public ulong unknown5;
	public string input;
	public string output;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string command, string overload=string.init, uint unknown2=uint.init, uint unknown3=uint.init, bool isOutput=bool.init, ulong unknown5=ulong.init, string input=string.init, string output=string.init) {
		this.command = command;
		this.overload = overload;
		this.unknown2 = unknown2;
		this.unknown3 = unknown3;
		this.isOutput = isOutput;
		this.unknown5 = unknown5;
		this.input = input;
		this.output = output;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)command.length)); writeString(command);
		writeBytes(varuint.encode(cast(uint)overload.length)); writeString(overload);
		writeBytes(varuint.encode(unknown2));
		writeBytes(varuint.encode(unknown3));
		writeBigEndianBool(isOutput);
		writeBytes(varulong.encode(unknown5));
		writeBytes(varuint.encode(cast(uint)input.length)); writeString(input);
		writeBytes(varuint.encode(cast(uint)output.length)); writeString(output);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		uint y29tbwfuza=varuint.decode(_buffer, &_index); command=readString(y29tbwfuza);
		uint b3zlcmxvywq=varuint.decode(_buffer, &_index); overload=readString(b3zlcmxvywq);
		unknown2=varuint.decode(_buffer, &_index);
		unknown3=varuint.decode(_buffer, &_index);
		isOutput=readBigEndianBool();
		unknown5=varulong.decode(_buffer, &_index);
		uint aw5wdxq=varuint.decode(_buffer, &_index); input=readString(aw5wdxq);
		uint b3v0chv0=varuint.decode(_buffer, &_index); output=readString(b3v0chv0);
	}

	public static pure nothrow @safe CommandStep fromBuffer(bool readId=true)(ubyte[] buffer) {
		CommandStep ret = new CommandStep();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "CommandStep(command: " ~ std.conv.to!string(this.command) ~ ", overload: " ~ std.conv.to!string(this.overload) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ", unknown3: " ~ std.conv.to!string(this.unknown3) ~ ", isOutput: " ~ std.conv.to!string(this.isOutput) ~ ", unknown5: " ~ std.conv.to!string(this.unknown5) ~ ", input: " ~ std.conv.to!string(this.input) ~ ", output: " ~ std.conv.to!string(this.output) ~ ")";
	}

}

class ResourcePackDataInfo : Buffer {

	public enum ubyte ID = 79;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["id", "unknown1", "unknown2", "unknown3", "unknown4"];

	public string id;
	public uint unknown1;
	public uint unknown2;
	public ulong unknown3;
	public string unknown4;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string id, uint unknown1=uint.init, uint unknown2=uint.init, ulong unknown3=ulong.init, string unknown4=string.init) {
		this.id = id;
		this.unknown1 = unknown1;
		this.unknown2 = unknown2;
		this.unknown3 = unknown3;
		this.unknown4 = unknown4;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)id.length)); writeString(id);
		writeBigEndianUint(unknown1);
		writeBigEndianUint(unknown2);
		writeBigEndianUlong(unknown3);
		writeBytes(varuint.encode(cast(uint)unknown4.length)); writeString(unknown4);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		uint awq=varuint.decode(_buffer, &_index); id=readString(awq);
		unknown1=readBigEndianUint();
		unknown2=readBigEndianUint();
		unknown3=readBigEndianUlong();
		uint dw5rbm93bjq=varuint.decode(_buffer, &_index); unknown4=readString(dw5rbm93bjq);
	}

	public static pure nothrow @safe ResourcePackDataInfo fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePackDataInfo ret = new ResourcePackDataInfo();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePackDataInfo(id: " ~ std.conv.to!string(this.id) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ", unknown3: " ~ std.conv.to!string(this.unknown3) ~ ", unknown4: " ~ std.conv.to!string(this.unknown4) ~ ")";
	}

}

class ResourcePackChunkData : Buffer {

	public enum ubyte ID = 80;

	public enum bool CLIENTBOUND = true;
	public enum bool SERVERBOUND = false;

	public enum string[] FIELDS = ["id", "unknown1", "unknown2", "data"];

	public string id;
	public uint unknown1;
	public ulong unknown2;
	public ubyte[] data;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string id, uint unknown1=uint.init, ulong unknown2=ulong.init, ubyte[] data=(ubyte[]).init) {
		this.id = id;
		this.unknown1 = unknown1;
		this.unknown2 = unknown2;
		this.data = data;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)id.length)); writeString(id);
		writeBigEndianUint(unknown1);
		writeBigEndianUlong(unknown2);
		writeBytes(varuint.encode(cast(uint)data.length)); writeBytes(data);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		uint awq=varuint.decode(_buffer, &_index); id=readString(awq);
		unknown1=readBigEndianUint();
		unknown2=readBigEndianUlong();
		data.length=varuint.decode(_buffer, &_index); if(_buffer.length>=_index+data.length){ data=_buffer[_index.._index+data.length].dup; _index+=data.length; }
	}

	public static pure nothrow @safe ResourcePackChunkData fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePackChunkData ret = new ResourcePackChunkData();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePackChunkData(id: " ~ std.conv.to!string(this.id) ~ ", unknown1: " ~ std.conv.to!string(this.unknown1) ~ ", unknown2: " ~ std.conv.to!string(this.unknown2) ~ ", data: " ~ std.conv.to!string(this.data) ~ ")";
	}

}

class ResourcePackChunkRequest : Buffer {

	public enum ubyte ID = 81;

	public enum bool CLIENTBOUND = false;
	public enum bool SERVERBOUND = true;

	public enum string[] FIELDS = ["id", "index"];

	public string id;
	public uint index;

	public pure nothrow @safe @nogc this() {}

	public pure nothrow @safe @nogc this(string id, uint index=uint.init) {
		this.id = id;
		this.index = index;
	}

	public pure nothrow @safe ubyte[] encode(bool writeId=true)() {
		_buffer.length = 0;
		static if(writeId){ writeBigEndianUbyte(ID); }
		writeBytes(varuint.encode(cast(uint)id.length)); writeString(id);
		writeBigEndianUint(index);
		return _buffer;
	}

	public pure nothrow @safe void decode(bool readId=true)() {
		static if(readId){ ubyte _id; _id=readBigEndianUbyte(); }
		uint awq=varuint.decode(_buffer, &_index); id=readString(awq);
		index=readBigEndianUint();
	}

	public static pure nothrow @safe ResourcePackChunkRequest fromBuffer(bool readId=true)(ubyte[] buffer) {
		ResourcePackChunkRequest ret = new ResourcePackChunkRequest();
		ret._buffer = buffer;
		ret.decode!readId();
		return ret;
	}

	public override string toString() {
		return "ResourcePackChunkRequest(id: " ~ std.conv.to!string(this.id) ~ ", index: " ~ std.conv.to!string(this.index) ~ ")";
	}

}
